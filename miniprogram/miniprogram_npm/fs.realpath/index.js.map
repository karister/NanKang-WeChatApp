{"version":3,"sources":["index.js","old.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = realpath\r\nrealpath.realpath = realpath\r\nrealpath.sync = realpathSync\r\nrealpath.realpathSync = realpathSync\r\nrealpath.monkeypatch = monkeypatch\r\nrealpath.unmonkeypatch = unmonkeypatch\r\n\r\nvar fs = require('fs')\r\nvar origRealpath = fs.realpath\r\nvar origRealpathSync = fs.realpathSync\r\n\r\nvar version = process.version\r\nvar ok = /^v[0-5]\\./.test(version)\r\nvar old = require('./old.js')\r\n\r\nfunction newError (er) {\r\n  return er && er.syscall === 'realpath' && (\r\n    er.code === 'ELOOP' ||\r\n    er.code === 'ENOMEM' ||\r\n    er.code === 'ENAMETOOLONG'\r\n  )\r\n}\r\n\r\nfunction realpath (p, cache, cb) {\r\n  if (ok) {\r\n    return origRealpath(p, cache, cb)\r\n  }\r\n\r\n  if (typeof cache === 'function') {\r\n    cb = cache\r\n    cache = null\r\n  }\r\n  origRealpath(p, cache, function (er, result) {\r\n    if (newError(er)) {\r\n      old.realpath(p, cache, cb)\r\n    } else {\r\n      cb(er, result)\r\n    }\r\n  })\r\n}\r\n\r\nfunction realpathSync (p, cache) {\r\n  if (ok) {\r\n    return origRealpathSync(p, cache)\r\n  }\r\n\r\n  try {\r\n    return origRealpathSync(p, cache)\r\n  } catch (er) {\r\n    if (newError(er)) {\r\n      return old.realpathSync(p, cache)\r\n    } else {\r\n      throw er\r\n    }\r\n  }\r\n}\r\n\r\nfunction monkeypatch () {\r\n  fs.realpath = realpath\r\n  fs.realpathSync = realpathSync\r\n}\r\n\r\nfunction unmonkeypatch () {\r\n  fs.realpath = origRealpath\r\n  fs.realpathSync = origRealpathSync\r\n}\r\n","// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nvar pathModule = require('path');\r\nvar isWindows = process.platform === 'win32';\r\nvar fs = require('fs');\r\n\r\n// JavaScript implementation of realpath, ported from node pre-v6\r\n\r\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\r\n\r\nfunction rethrow() {\r\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\r\n  // is fairly slow to generate.\r\n  var callback;\r\n  if (DEBUG) {\r\n    var backtrace = new Error;\r\n    callback = debugCallback;\r\n  } else\r\n    callback = missingCallback;\r\n\r\n  return callback;\r\n\r\n  function debugCallback(err) {\r\n    if (err) {\r\n      backtrace.message = err.message;\r\n      err = backtrace;\r\n      missingCallback(err);\r\n    }\r\n  }\r\n\r\n  function missingCallback(err) {\r\n    if (err) {\r\n      if (process.throwDeprecation)\r\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\r\n      else if (!process.noDeprecation) {\r\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\r\n        if (process.traceDeprecation)\r\n          console.trace(msg);\r\n        else\r\n          console.error(msg);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction maybeCallback(cb) {\r\n  return typeof cb === 'function' ? cb : rethrow();\r\n}\r\n\r\nvar normalize = pathModule.normalize;\r\n\r\n// Regexp that finds the next partion of a (partial) path\r\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\r\nif (isWindows) {\r\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\r\n} else {\r\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\r\n}\r\n\r\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\r\nif (isWindows) {\r\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\r\n} else {\r\n  var splitRootRe = /^[\\/]*/;\r\n}\r\n\r\nexports.realpathSync = function realpathSync(p, cache) {\r\n  // make p is absolute\r\n  p = pathModule.resolve(p);\r\n\r\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\r\n    return cache[p];\r\n  }\r\n\r\n  var original = p,\r\n      seenLinks = {},\r\n      knownHard = {};\r\n\r\n  // current character position in p\r\n  var pos;\r\n  // the partial path so far, including a trailing slash if any\r\n  var current;\r\n  // the partial path without a trailing slash (except when pointing at a root)\r\n  var base;\r\n  // the partial path scanned in the previous round, with slash\r\n  var previous;\r\n\r\n  start();\r\n\r\n  function start() {\r\n    // Skip over roots\r\n    var m = splitRootRe.exec(p);\r\n    pos = m[0].length;\r\n    current = m[0];\r\n    base = m[0];\r\n    previous = '';\r\n\r\n    // On windows, check that the root exists. On unix there is no need.\r\n    if (isWindows && !knownHard[base]) {\r\n      fs.lstatSync(base);\r\n      knownHard[base] = true;\r\n    }\r\n  }\r\n\r\n  // walk down the path, swapping out linked pathparts for their real\r\n  // values\r\n  // NB: p.length changes.\r\n  while (pos < p.length) {\r\n    // find the next part\r\n    nextPartRe.lastIndex = pos;\r\n    var result = nextPartRe.exec(p);\r\n    previous = current;\r\n    current += result[0];\r\n    base = previous + result[1];\r\n    pos = nextPartRe.lastIndex;\r\n\r\n    // continue if not a symlink\r\n    if (knownHard[base] || (cache && cache[base] === base)) {\r\n      continue;\r\n    }\r\n\r\n    var resolvedLink;\r\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\r\n      // some known symbolic link.  no need to stat again.\r\n      resolvedLink = cache[base];\r\n    } else {\r\n      var stat = fs.lstatSync(base);\r\n      if (!stat.isSymbolicLink()) {\r\n        knownHard[base] = true;\r\n        if (cache) cache[base] = base;\r\n        continue;\r\n      }\r\n\r\n      // read the link if it wasn't read before\r\n      // dev/ino always return 0 on windows, so skip the check.\r\n      var linkTarget = null;\r\n      if (!isWindows) {\r\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\r\n        if (seenLinks.hasOwnProperty(id)) {\r\n          linkTarget = seenLinks[id];\r\n        }\r\n      }\r\n      if (linkTarget === null) {\r\n        fs.statSync(base);\r\n        linkTarget = fs.readlinkSync(base);\r\n      }\r\n      resolvedLink = pathModule.resolve(previous, linkTarget);\r\n      // track this, if given a cache.\r\n      if (cache) cache[base] = resolvedLink;\r\n      if (!isWindows) seenLinks[id] = linkTarget;\r\n    }\r\n\r\n    // resolve the link, then start over\r\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\r\n    start();\r\n  }\r\n\r\n  if (cache) cache[original] = p;\r\n\r\n  return p;\r\n};\r\n\r\n\r\nexports.realpath = function realpath(p, cache, cb) {\r\n  if (typeof cb !== 'function') {\r\n    cb = maybeCallback(cache);\r\n    cache = null;\r\n  }\r\n\r\n  // make p is absolute\r\n  p = pathModule.resolve(p);\r\n\r\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\r\n    return process.nextTick(cb.bind(null, null, cache[p]));\r\n  }\r\n\r\n  var original = p,\r\n      seenLinks = {},\r\n      knownHard = {};\r\n\r\n  // current character position in p\r\n  var pos;\r\n  // the partial path so far, including a trailing slash if any\r\n  var current;\r\n  // the partial path without a trailing slash (except when pointing at a root)\r\n  var base;\r\n  // the partial path scanned in the previous round, with slash\r\n  var previous;\r\n\r\n  start();\r\n\r\n  function start() {\r\n    // Skip over roots\r\n    var m = splitRootRe.exec(p);\r\n    pos = m[0].length;\r\n    current = m[0];\r\n    base = m[0];\r\n    previous = '';\r\n\r\n    // On windows, check that the root exists. On unix there is no need.\r\n    if (isWindows && !knownHard[base]) {\r\n      fs.lstat(base, function(err) {\r\n        if (err) return cb(err);\r\n        knownHard[base] = true;\r\n        LOOP();\r\n      });\r\n    } else {\r\n      process.nextTick(LOOP);\r\n    }\r\n  }\r\n\r\n  // walk down the path, swapping out linked pathparts for their real\r\n  // values\r\n  function LOOP() {\r\n    // stop if scanned past end of path\r\n    if (pos >= p.length) {\r\n      if (cache) cache[original] = p;\r\n      return cb(null, p);\r\n    }\r\n\r\n    // find the next part\r\n    nextPartRe.lastIndex = pos;\r\n    var result = nextPartRe.exec(p);\r\n    previous = current;\r\n    current += result[0];\r\n    base = previous + result[1];\r\n    pos = nextPartRe.lastIndex;\r\n\r\n    // continue if not a symlink\r\n    if (knownHard[base] || (cache && cache[base] === base)) {\r\n      return process.nextTick(LOOP);\r\n    }\r\n\r\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\r\n      // known symbolic link.  no need to stat again.\r\n      return gotResolvedLink(cache[base]);\r\n    }\r\n\r\n    return fs.lstat(base, gotStat);\r\n  }\r\n\r\n  function gotStat(err, stat) {\r\n    if (err) return cb(err);\r\n\r\n    // if not a symlink, skip to the next path part\r\n    if (!stat.isSymbolicLink()) {\r\n      knownHard[base] = true;\r\n      if (cache) cache[base] = base;\r\n      return process.nextTick(LOOP);\r\n    }\r\n\r\n    // stat & read the link if not read before\r\n    // call gotTarget as soon as the link target is known\r\n    // dev/ino always return 0 on windows, so skip the check.\r\n    if (!isWindows) {\r\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\r\n      if (seenLinks.hasOwnProperty(id)) {\r\n        return gotTarget(null, seenLinks[id], base);\r\n      }\r\n    }\r\n    fs.stat(base, function(err) {\r\n      if (err) return cb(err);\r\n\r\n      fs.readlink(base, function(err, target) {\r\n        if (!isWindows) seenLinks[id] = target;\r\n        gotTarget(err, target);\r\n      });\r\n    });\r\n  }\r\n\r\n  function gotTarget(err, target, base) {\r\n    if (err) return cb(err);\r\n\r\n    var resolvedLink = pathModule.resolve(previous, target);\r\n    if (cache) cache[base] = resolvedLink;\r\n    gotResolvedLink(resolvedLink);\r\n  }\r\n\r\n  function gotResolvedLink(resolvedLink) {\r\n    // resolve the link, then start over\r\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\r\n    start();\r\n  }\r\n};\r\n"]}