{"version":3,"sources":["index.js","fs/index.js","copy-sync/index.js","copy-sync/copy-sync.js","mkdirs/index.js","mkdirs/mkdirs.js","mkdirs/win32.js","mkdirs/mkdirs-sync.js","util/utimes.js","util/stat.js","util/buffer.js","copy/index.js","copy/copy.js","path-exists/index.js","empty/index.js","remove/index.js","remove/rimraf.js","ensure/index.js","ensure/file.js","ensure/link.js","ensure/symlink.js","ensure/symlink-paths.js","ensure/symlink-type.js","json/index.js","json/jsonfile.js","json/output-json.js","json/output-json-sync.js","move-sync/index.js","move-sync/move-sync.js","move/index.js","move/move.js","output/index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA,ACHA;AFOA,AFMA,ADGA,AIZA,ACHA;AFOA,AFMA,ADGA,AIZA,ACHA;AFOA,AFMA,ADGA,AIZA,ACHA,ACHA;AHUA,AFMA,ADGA,AIZA,ACHA,ACHA;AHUA,AFMA,ADGA,AIZA,ACHA,ACHA;AHUA,AFMA,ADGA,AIZA,AGTA,AFMA,ACHA;AHUA,AFMA,ADGA,AIZA,AGTA,AFMA,ACHA;AHUA,AFMA,ADGA,AIZA,AGTA,AFMA,ACHA;AHUA,AFMA,ADGA,AIZA,AGTA,AFMA,ACHA,AENA;ALgBA,AFMA,ADGA,AIZA,AGTA,AFMA,ACHA,AENA;ALgBA,AFMA,ADGA,AIZA,AGTA,AFMA,ACHA,AENA;ALgBA,AFMA,ADGA,AOrBA,AFMA,ACHA,AGTA,ADGA;ALgBA,AFMA,ADGA,AOrBA,AFMA,ACHA,AGTA,ADGA;ALgBA,AFMA,AMlBA,AFMA,ACHA,AGTA,ADGA;ALgBA,AFMA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AFMA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AFMA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AQxBA,AV8BA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AQxBA,AV8BA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AQxBA,AV8BA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AS3BA,ADGA,AV8BA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AS3BA,ADGA,AV8BA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AS3BA,ADGA,AV8BA,AMlBA,AFMA,ACHA,AIZA,ADGA,ADGA;ALgBA,AS3BA,ADGA,AV8BA,AMlBA,AFMA,ACHA,AOrBA,AHSA,ADGA,ADGA;ALgBA,AS3BA,AXiCA,AMlBA,AFMA,ACHA,AOrBA,AHSA,ADGA,ADGA;ALgBA,AS3BA,AXiCA,AMlBA,AFMA,ACHA,AOrBA,AHSA,ADGA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,ACHA,AOrBA,AHSA,ADGA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,ACHA,AOrBA,AJYA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,AQxBA,AJYA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,AQxBA,AENA,ANkBA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,AQxBA,AENA,ANkBA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,AQxBA,AENA,ANkBA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,AQxBA,AENA,ACHA,APqBA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,AQxBA,AENA,ACHA,APqBA,ADGA;ALgBA,AS3BA,AENA,AbuCA,AMlBA,AFMA,AQxBA,AENA,ACHA,APqBA,ADGA;ALgBA,AS3BA,AENA,AGTA,AhBgDA,AMlBA,AFMA,AQxBA,AENA,ACHA,APqBA,ADGA;ALgBA,AS3BA,AENA,AGTA,AhBgDA,AMlBA,AFMA,AU9BA,ACHA,APqBA,ADGA;ALgBA,AS3BA,AENA,AGTA,AhBgDA,AMlBA,AFMA,AU9BA,ACHA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AhBgDA,AMlBA,AFMA,AU9BA,ACHA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AhBgDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AhBgDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AlBsDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AlBsDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AlBsDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,ACHA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,ACHA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,ACHA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ADGA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ADGA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ADGA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AMlBA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AsBlEA,AhBgDA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AsBlEA,AhBgDA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AsBlEA,AhBgDA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AjBmDA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AjBmDA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ADGA,AENA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AjBmDA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,ACHA,AlBsDA,AFMA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,ACHA,ApB4DA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,ACHA,ApB4DA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AENA,ADGA,ApB4DA,AWjCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AENA,ADGA,AT2BA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AENA,ADGA,AT2BA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AENA,ADGA,AENA,AXiCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AENA,ADGA,AENA,AXiCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AENA,ADGA,AENA,AXiCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,ACHA,AENA,ADGA,AENA,ACHA,AZoCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AsBlEA,AGTA,ADGA,AENA,ACHA,AZoCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AENA,ACHA,AZoCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,ACHA,AbuCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,ACHA,AbuCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,ACHA,AbuCA,APqBA,ADGA;ALgBA,AS3BA,AENA,AIZA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,ACHA,ACHA,Ad0CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,ACHA,ACHA,Ad0CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,ACHA,ACHA,Ad0CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,ACHA,ACHA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ACHA,AFMA,AnByDA,AyB3EA,ADGA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ACHA,AFMA,AnByDA,AwBxEA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ADGA,AnByDA,AwBxEA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ADGA,AnByDA,AwBxEA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ADGA,AnByDA,AwBxEA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ADGA,AnByDA,AwBxEA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ADGA,AnByDA,AwBxEA,AGTA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AMlBA,ACHA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA,ADGA;ALgBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AnByDA,A2BjFA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AOrBA,AENA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,ADGA,AQxBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AOrBA,AENA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,ACHA,Af6CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,AS3BA,Ad0CA,APqBA;ANmBA,AS3BA,AS3BA,ALeA,APqBA;ANmBA,AS3BA,AS3BA,ALeA,APqBA;ANmBA,AS3BA,AS3BA,ALeA,APqBA;ANmBA,AS3BA,AS3BA,ALeA,APqBA;ANmBA,AS3BA,AS3BA,ALeA,APqBA;ANmBA,AS3BA,AS3BA,ALeA,APqBA;ANmBA,AS3BA,AS3BA,ALeA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;ANmBA,AS3BA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA,APqBA;AGRA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nmodule.exports = Object.assign(\r\n  {},\r\n  // Export promiseified graceful-fs:\r\n  require('./fs'),\r\n  // Export extra methods:\r\n  require('./copy-sync'),\r\n  require('./copy'),\r\n  require('./empty'),\r\n  require('./ensure'),\r\n  require('./json'),\r\n  require('./mkdirs'),\r\n  require('./move-sync'),\r\n  require('./move'),\r\n  require('./output'),\r\n  require('./path-exists'),\r\n  require('./remove')\r\n)\r\n\r\n// Export fs.promises as a getter property so that we don't trigger\r\n// ExperimentalWarning before fs.promises is actually accessed.\r\nconst fs = require('fs')\r\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\r\n  Object.defineProperty(module.exports, 'promises', {\r\n    get () { return fs.promises }\r\n  })\r\n}\r\n","\r\n// This is adapted from https://github.com/normalize/mz\r\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\r\nconst u = require('universalify').fromCallback\r\nconst fs = require('graceful-fs')\r\n\r\nconst api = [\r\n  'access',\r\n  'appendFile',\r\n  'chmod',\r\n  'chown',\r\n  'close',\r\n  'copyFile',\r\n  'fchmod',\r\n  'fchown',\r\n  'fdatasync',\r\n  'fstat',\r\n  'fsync',\r\n  'ftruncate',\r\n  'futimes',\r\n  'lchown',\r\n  'lchmod',\r\n  'link',\r\n  'lstat',\r\n  'mkdir',\r\n  'mkdtemp',\r\n  'open',\r\n  'readFile',\r\n  'readdir',\r\n  'readlink',\r\n  'realpath',\r\n  'rename',\r\n  'rmdir',\r\n  'stat',\r\n  'symlink',\r\n  'truncate',\r\n  'unlink',\r\n  'utimes',\r\n  'writeFile'\r\n].filter(key => {\r\n  // Some commands are not available on some systems. Ex:\r\n  // fs.copyFile was added in Node.js v8.5.0\r\n  // fs.mkdtemp was added in Node.js v5.10.0\r\n  // fs.lchown is not available on at least some Linux\r\n  return typeof fs[key] === 'function'\r\n})\r\n\r\n// Export all keys:\r\nObject.keys(fs).forEach(key => {\r\n  if (key === 'promises') {\r\n    // fs.promises is a getter property that triggers ExperimentalWarning\r\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\r\n    return\r\n  }\r\n  exports[key] = fs[key]\r\n})\r\n\r\n// Universalify async methods:\r\napi.forEach(method => {\r\n  exports[method] = u(fs[method])\r\n})\r\n\r\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\r\n// since we are a drop-in replacement for the native module\r\nexports.exists = function (filename, callback) {\r\n  if (typeof callback === 'function') {\r\n    return fs.exists(filename, callback)\r\n  }\r\n  return new Promise(resolve => {\r\n    return fs.exists(filename, resolve)\r\n  })\r\n}\r\n\r\n// fs.read() & fs.write need special treatment due to multiple callback args\r\n\r\nexports.read = function (fd, buffer, offset, length, position, callback) {\r\n  if (typeof callback === 'function') {\r\n    return fs.read(fd, buffer, offset, length, position, callback)\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\r\n      if (err) return reject(err)\r\n      resolve({ bytesRead, buffer })\r\n    })\r\n  })\r\n}\r\n\r\n// Function signature can be\r\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\r\n// OR\r\n// fs.write(fd, string[, position[, encoding]], callback)\r\n// We need to handle both cases, so we use ...args\r\nexports.write = function (fd, buffer, ...args) {\r\n  if (typeof args[args.length - 1] === 'function') {\r\n    return fs.write(fd, buffer, ...args)\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\r\n      if (err) return reject(err)\r\n      resolve({ bytesWritten, buffer })\r\n    })\r\n  })\r\n}\r\n\r\n// fs.realpath.native only available in Node v9.2+\r\nif (typeof fs.realpath.native === 'function') {\r\n  exports.realpath.native = u(fs.realpath.native)\r\n}\r\n","\r\n\r\nmodule.exports = {\r\n  copySync: require('./copy-sync')\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst mkdirpSync = require('../mkdirs').mkdirsSync\r\nconst utimesSync = require('../util/utimes.js').utimesMillisSync\r\nconst stat = require('../util/stat')\r\n\r\nfunction copySync (src, dest, opts) {\r\n  if (typeof opts === 'function') {\r\n    opts = { filter: opts }\r\n  }\r\n\r\n  opts = opts || {}\r\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\r\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\r\n\r\n  // Warn about using preserveTimestamps on 32-bit node\r\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\r\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\r\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\r\n  }\r\n\r\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\r\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\r\n  return handleFilterAndCopy(destStat, src, dest, opts)\r\n}\r\n\r\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\r\n  if (opts.filter && !opts.filter(src, dest)) return\r\n  const destParent = path.dirname(dest)\r\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\r\n  return startCopy(destStat, src, dest, opts)\r\n}\r\n\r\nfunction startCopy (destStat, src, dest, opts) {\r\n  if (opts.filter && !opts.filter(src, dest)) return\r\n  return getStats(destStat, src, dest, opts)\r\n}\r\n\r\nfunction getStats (destStat, src, dest, opts) {\r\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\r\n  const srcStat = statSync(src)\r\n\r\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\r\n  else if (srcStat.isFile() ||\r\n           srcStat.isCharacterDevice() ||\r\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\r\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\r\n}\r\n\r\nfunction onFile (srcStat, destStat, src, dest, opts) {\r\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\r\n  return mayCopyFile(srcStat, src, dest, opts)\r\n}\r\n\r\nfunction mayCopyFile (srcStat, src, dest, opts) {\r\n  if (opts.overwrite) {\r\n    fs.unlinkSync(dest)\r\n    return copyFile(srcStat, src, dest, opts)\r\n  } else if (opts.errorOnExist) {\r\n    throw new Error(`'${dest}' already exists`)\r\n  }\r\n}\r\n\r\nfunction copyFile (srcStat, src, dest, opts) {\r\n  if (typeof fs.copyFileSync === 'function') {\r\n    fs.copyFileSync(src, dest)\r\n    fs.chmodSync(dest, srcStat.mode)\r\n    if (opts.preserveTimestamps) {\r\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\r\n    }\r\n    return\r\n  }\r\n  return copyFileFallback(srcStat, src, dest, opts)\r\n}\r\n\r\nfunction copyFileFallback (srcStat, src, dest, opts) {\r\n  const BUF_LENGTH = 64 * 1024\r\n  const _buff = require('../util/buffer')(BUF_LENGTH)\r\n\r\n  const fdr = fs.openSync(src, 'r')\r\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\r\n  let pos = 0\r\n\r\n  while (pos < srcStat.size) {\r\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\r\n    fs.writeSync(fdw, _buff, 0, bytesRead)\r\n    pos += bytesRead\r\n  }\r\n\r\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\r\n\r\n  fs.closeSync(fdr)\r\n  fs.closeSync(fdw)\r\n}\r\n\r\nfunction onDir (srcStat, destStat, src, dest, opts) {\r\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)\r\n  if (destStat && !destStat.isDirectory()) {\r\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\r\n  }\r\n  return copyDir(src, dest, opts)\r\n}\r\n\r\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\r\n  fs.mkdirSync(dest)\r\n  copyDir(src, dest, opts)\r\n  return fs.chmodSync(dest, srcStat.mode)\r\n}\r\n\r\nfunction copyDir (src, dest, opts) {\r\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\r\n}\r\n\r\nfunction copyDirItem (item, src, dest, opts) {\r\n  const srcItem = path.join(src, item)\r\n  const destItem = path.join(dest, item)\r\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\r\n  return startCopy(destStat, srcItem, destItem, opts)\r\n}\r\n\r\nfunction onLink (destStat, src, dest, opts) {\r\n  let resolvedSrc = fs.readlinkSync(src)\r\n  if (opts.dereference) {\r\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\r\n  }\r\n\r\n  if (!destStat) {\r\n    return fs.symlinkSync(resolvedSrc, dest)\r\n  } else {\r\n    let resolvedDest\r\n    try {\r\n      resolvedDest = fs.readlinkSync(dest)\r\n    } catch (err) {\r\n      // dest exists and is a regular file or directory,\r\n      // Windows may throw UNKNOWN error. If dest already exists,\r\n      // fs throws error anyway, so no need to guard against it here.\r\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\r\n      throw err\r\n    }\r\n    if (opts.dereference) {\r\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\r\n    }\r\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\r\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\r\n    }\r\n\r\n    // prevent copy if src is a subdir of dest since unlinking\r\n    // dest in this case would result in removing src contents\r\n    // and therefore a broken symlink would be created.\r\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\r\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\r\n    }\r\n    return copyLink(resolvedSrc, dest)\r\n  }\r\n}\r\n\r\nfunction copyLink (resolvedSrc, dest) {\r\n  fs.unlinkSync(dest)\r\n  return fs.symlinkSync(resolvedSrc, dest)\r\n}\r\n\r\nmodule.exports = copySync\r\n","\r\nconst u = require('universalify').fromCallback\r\nconst mkdirs = u(require('./mkdirs'))\r\nconst mkdirsSync = require('./mkdirs-sync')\r\n\r\nmodule.exports = {\r\n  mkdirs,\r\n  mkdirsSync,\r\n  // alias\r\n  mkdirp: mkdirs,\r\n  mkdirpSync: mkdirsSync,\r\n  ensureDir: mkdirs,\r\n  ensureDirSync: mkdirsSync\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst invalidWin32Path = require('./win32').invalidWin32Path\r\n\r\nconst o777 = parseInt('0777', 8)\r\n\r\nfunction mkdirs (p, opts, callback, made) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts\r\n    opts = {}\r\n  } else if (!opts || typeof opts !== 'object') {\r\n    opts = { mode: opts }\r\n  }\r\n\r\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\r\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\r\n    errInval.code = 'EINVAL'\r\n    return callback(errInval)\r\n  }\r\n\r\n  let mode = opts.mode\r\n  const xfs = opts.fs || fs\r\n\r\n  if (mode === undefined) {\r\n    mode = o777 & (~process.umask())\r\n  }\r\n  if (!made) made = null\r\n\r\n  callback = callback || function () {}\r\n  p = path.resolve(p)\r\n\r\n  xfs.mkdir(p, mode, er => {\r\n    if (!er) {\r\n      made = made || p\r\n      return callback(null, made)\r\n    }\r\n    switch (er.code) {\r\n      case 'ENOENT':\r\n        if (path.dirname(p) === p) return callback(er)\r\n        mkdirs(path.dirname(p), opts, (er, made) => {\r\n          if (er) callback(er, made)\r\n          else mkdirs(p, opts, callback, made)\r\n        })\r\n        break\r\n\r\n      // In the case of any other error, just see if there's a dir\r\n      // there already.  If so, then hooray!  If not, then something\r\n      // is borked.\r\n      default:\r\n        xfs.stat(p, (er2, stat) => {\r\n          // if the stat fails, then that's super weird.\r\n          // let the original error be the failure reason.\r\n          if (er2 || !stat.isDirectory()) callback(er, made)\r\n          else callback(null, made)\r\n        })\r\n        break\r\n    }\r\n  })\r\n}\r\n\r\nmodule.exports = mkdirs\r\n","\r\n\r\nconst path = require('path')\r\n\r\n// get drive on windows\r\nfunction getRootPath (p) {\r\n  p = path.normalize(path.resolve(p)).split(path.sep)\r\n  if (p.length > 0) return p[0]\r\n  return null\r\n}\r\n\r\n// http://stackoverflow.com/a/62888/10333 contains more accurate\r\n// TODO: expand to include the rest\r\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\r\n\r\nfunction invalidWin32Path (p) {\r\n  const rp = getRootPath(p)\r\n  p = p.replace(rp, '')\r\n  return INVALID_PATH_CHARS.test(p)\r\n}\r\n\r\nmodule.exports = {\r\n  getRootPath,\r\n  invalidWin32Path\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst invalidWin32Path = require('./win32').invalidWin32Path\r\n\r\nconst o777 = parseInt('0777', 8)\r\n\r\nfunction mkdirsSync (p, opts, made) {\r\n  if (!opts || typeof opts !== 'object') {\r\n    opts = { mode: opts }\r\n  }\r\n\r\n  let mode = opts.mode\r\n  const xfs = opts.fs || fs\r\n\r\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\r\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\r\n    errInval.code = 'EINVAL'\r\n    throw errInval\r\n  }\r\n\r\n  if (mode === undefined) {\r\n    mode = o777 & (~process.umask())\r\n  }\r\n  if (!made) made = null\r\n\r\n  p = path.resolve(p)\r\n\r\n  try {\r\n    xfs.mkdirSync(p, mode)\r\n    made = made || p\r\n  } catch (err0) {\r\n    if (err0.code === 'ENOENT') {\r\n      if (path.dirname(p) === p) throw err0\r\n      made = mkdirsSync(path.dirname(p), opts, made)\r\n      mkdirsSync(p, opts, made)\r\n    } else {\r\n      // In the case of any other error, just see if there's a dir there\r\n      // already. If so, then hooray!  If not, then something is borked.\r\n      let stat\r\n      try {\r\n        stat = xfs.statSync(p)\r\n      } catch (err1) {\r\n        throw err0\r\n      }\r\n      if (!stat.isDirectory()) throw err0\r\n    }\r\n  }\r\n\r\n  return made\r\n}\r\n\r\nmodule.exports = mkdirsSync\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst os = require('os')\r\nconst path = require('path')\r\n\r\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\r\nfunction hasMillisResSync () {\r\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\r\n  tmpfile = path.join(os.tmpdir(), tmpfile)\r\n\r\n  // 550 millis past UNIX epoch\r\n  const d = new Date(1435410243862)\r\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\r\n  const fd = fs.openSync(tmpfile, 'r+')\r\n  fs.futimesSync(fd, d, d)\r\n  fs.closeSync(fd)\r\n  return fs.statSync(tmpfile).mtime > 1435410243000\r\n}\r\n\r\nfunction hasMillisRes (callback) {\r\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\r\n  tmpfile = path.join(os.tmpdir(), tmpfile)\r\n\r\n  // 550 millis past UNIX epoch\r\n  const d = new Date(1435410243862)\r\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\r\n    if (err) return callback(err)\r\n    fs.open(tmpfile, 'r+', (err, fd) => {\r\n      if (err) return callback(err)\r\n      fs.futimes(fd, d, d, err => {\r\n        if (err) return callback(err)\r\n        fs.close(fd, err => {\r\n          if (err) return callback(err)\r\n          fs.stat(tmpfile, (err, stats) => {\r\n            if (err) return callback(err)\r\n            callback(null, stats.mtime > 1435410243000)\r\n          })\r\n        })\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nfunction timeRemoveMillis (timestamp) {\r\n  if (typeof timestamp === 'number') {\r\n    return Math.floor(timestamp / 1000) * 1000\r\n  } else if (timestamp instanceof Date) {\r\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\r\n  } else {\r\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\r\n  }\r\n}\r\n\r\nfunction utimesMillis (path, atime, mtime, callback) {\r\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\r\n  fs.open(path, 'r+', (err, fd) => {\r\n    if (err) return callback(err)\r\n    fs.futimes(fd, atime, mtime, futimesErr => {\r\n      fs.close(fd, closeErr => {\r\n        if (callback) callback(futimesErr || closeErr)\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nfunction utimesMillisSync (path, atime, mtime) {\r\n  const fd = fs.openSync(path, 'r+')\r\n  fs.futimesSync(fd, atime, mtime)\r\n  return fs.closeSync(fd)\r\n}\r\n\r\nmodule.exports = {\r\n  hasMillisRes,\r\n  hasMillisResSync,\r\n  timeRemoveMillis,\r\n  utimesMillis,\r\n  utimesMillisSync\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\n\r\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\r\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\r\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\r\nconst nodeVersion = process.versions.node.split('.')\r\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\r\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\r\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\r\n\r\nfunction nodeSupportsBigInt () {\r\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\r\n    return true\r\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\r\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\r\n      return true\r\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\r\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\r\n        return true\r\n      }\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction getStats (src, dest, cb) {\r\n  if (nodeSupportsBigInt()) {\r\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\r\n      if (err) return cb(err)\r\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\r\n        if (err) {\r\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\r\n          return cb(err)\r\n        }\r\n        return cb(null, { srcStat, destStat })\r\n      })\r\n    })\r\n  } else {\r\n    fs.stat(src, (err, srcStat) => {\r\n      if (err) return cb(err)\r\n      fs.stat(dest, (err, destStat) => {\r\n        if (err) {\r\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\r\n          return cb(err)\r\n        }\r\n        return cb(null, { srcStat, destStat })\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\nfunction getStatsSync (src, dest) {\r\n  let srcStat, destStat\r\n  if (nodeSupportsBigInt()) {\r\n    srcStat = fs.statSync(src, { bigint: true })\r\n  } else {\r\n    srcStat = fs.statSync(src)\r\n  }\r\n  try {\r\n    if (nodeSupportsBigInt()) {\r\n      destStat = fs.statSync(dest, { bigint: true })\r\n    } else {\r\n      destStat = fs.statSync(dest)\r\n    }\r\n  } catch (err) {\r\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\r\n    throw err\r\n  }\r\n  return { srcStat, destStat }\r\n}\r\n\r\nfunction checkPaths (src, dest, funcName, cb) {\r\n  getStats(src, dest, (err, stats) => {\r\n    if (err) return cb(err)\r\n    const { srcStat, destStat } = stats\r\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\r\n      return cb(new Error('Source and destination must not be the same.'))\r\n    }\r\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\r\n      return cb(new Error(errMsg(src, dest, funcName)))\r\n    }\r\n    return cb(null, { srcStat, destStat })\r\n  })\r\n}\r\n\r\nfunction checkPathsSync (src, dest, funcName) {\r\n  const { srcStat, destStat } = getStatsSync(src, dest)\r\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\r\n    throw new Error('Source and destination must not be the same.')\r\n  }\r\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\r\n    throw new Error(errMsg(src, dest, funcName))\r\n  }\r\n  return { srcStat, destStat }\r\n}\r\n\r\n// recursively check if dest parent is a subdirectory of src.\r\n// It works for all file types including symlinks since it\r\n// checks the src and dest inodes. It starts from the deepest\r\n// parent and stops once it reaches the src parent or the root path.\r\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\r\n  const srcParent = path.resolve(path.dirname(src))\r\n  const destParent = path.resolve(path.dirname(dest))\r\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\r\n  if (nodeSupportsBigInt()) {\r\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\r\n      if (err) {\r\n        if (err.code === 'ENOENT') return cb()\r\n        return cb(err)\r\n      }\r\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\r\n        return cb(new Error(errMsg(src, dest, funcName)))\r\n      }\r\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\r\n    })\r\n  } else {\r\n    fs.stat(destParent, (err, destStat) => {\r\n      if (err) {\r\n        if (err.code === 'ENOENT') return cb()\r\n        return cb(err)\r\n      }\r\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\r\n        return cb(new Error(errMsg(src, dest, funcName)))\r\n      }\r\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\r\n    })\r\n  }\r\n}\r\n\r\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\r\n  const srcParent = path.resolve(path.dirname(src))\r\n  const destParent = path.resolve(path.dirname(dest))\r\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\r\n  let destStat\r\n  try {\r\n    if (nodeSupportsBigInt()) {\r\n      destStat = fs.statSync(destParent, { bigint: true })\r\n    } else {\r\n      destStat = fs.statSync(destParent)\r\n    }\r\n  } catch (err) {\r\n    if (err.code === 'ENOENT') return\r\n    throw err\r\n  }\r\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\r\n    throw new Error(errMsg(src, dest, funcName))\r\n  }\r\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\r\n}\r\n\r\n// return true if dest is a subdir of src, otherwise false.\r\n// It only checks the path strings.\r\nfunction isSrcSubdir (src, dest) {\r\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\r\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\r\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\r\n}\r\n\r\nfunction errMsg (src, dest, funcName) {\r\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\r\n}\r\n\r\nmodule.exports = {\r\n  checkPaths,\r\n  checkPathsSync,\r\n  checkParentPaths,\r\n  checkParentPathsSync,\r\n  isSrcSubdir\r\n}\r\n","\r\n/* eslint-disable node/no-deprecated-api */\r\nmodule.exports = function (size) {\r\n  if (typeof Buffer.allocUnsafe === 'function') {\r\n    try {\r\n      return Buffer.allocUnsafe(size)\r\n    } catch (e) {\r\n      return new Buffer(size)\r\n    }\r\n  }\r\n  return new Buffer(size)\r\n}\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nmodule.exports = {\r\n  copy: u(require('./copy'))\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst mkdirp = require('../mkdirs').mkdirs\r\nconst pathExists = require('../path-exists').pathExists\r\nconst utimes = require('../util/utimes').utimesMillis\r\nconst stat = require('../util/stat')\r\n\r\nfunction copy (src, dest, opts, cb) {\r\n  if (typeof opts === 'function' && !cb) {\r\n    cb = opts\r\n    opts = {}\r\n  } else if (typeof opts === 'function') {\r\n    opts = { filter: opts }\r\n  }\r\n\r\n  cb = cb || function () {}\r\n  opts = opts || {}\r\n\r\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\r\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\r\n\r\n  // Warn about using preserveTimestamps on 32-bit node\r\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\r\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\r\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\r\n  }\r\n\r\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\r\n    if (err) return cb(err)\r\n    const { srcStat, destStat } = stats\r\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\r\n      if (err) return cb(err)\r\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\r\n      return checkParentDir(destStat, src, dest, opts, cb)\r\n    })\r\n  })\r\n}\r\n\r\nfunction checkParentDir (destStat, src, dest, opts, cb) {\r\n  const destParent = path.dirname(dest)\r\n  pathExists(destParent, (err, dirExists) => {\r\n    if (err) return cb(err)\r\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\r\n    mkdirp(destParent, err => {\r\n      if (err) return cb(err)\r\n      return startCopy(destStat, src, dest, opts, cb)\r\n    })\r\n  })\r\n}\r\n\r\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\r\n  Promise.resolve(opts.filter(src, dest)).then(include => {\r\n    if (include) return onInclude(destStat, src, dest, opts, cb)\r\n    return cb()\r\n  }, error => cb(error))\r\n}\r\n\r\nfunction startCopy (destStat, src, dest, opts, cb) {\r\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\r\n  return getStats(destStat, src, dest, opts, cb)\r\n}\r\n\r\nfunction getStats (destStat, src, dest, opts, cb) {\r\n  const stat = opts.dereference ? fs.stat : fs.lstat\r\n  stat(src, (err, srcStat) => {\r\n    if (err) return cb(err)\r\n\r\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\r\n    else if (srcStat.isFile() ||\r\n             srcStat.isCharacterDevice() ||\r\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\r\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\r\n  })\r\n}\r\n\r\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\r\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\r\n  return mayCopyFile(srcStat, src, dest, opts, cb)\r\n}\r\n\r\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\r\n  if (opts.overwrite) {\r\n    fs.unlink(dest, err => {\r\n      if (err) return cb(err)\r\n      return copyFile(srcStat, src, dest, opts, cb)\r\n    })\r\n  } else if (opts.errorOnExist) {\r\n    return cb(new Error(`'${dest}' already exists`))\r\n  } else return cb()\r\n}\r\n\r\nfunction copyFile (srcStat, src, dest, opts, cb) {\r\n  if (typeof fs.copyFile === 'function') {\r\n    return fs.copyFile(src, dest, err => {\r\n      if (err) return cb(err)\r\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\r\n    })\r\n  }\r\n  return copyFileFallback(srcStat, src, dest, opts, cb)\r\n}\r\n\r\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\r\n  const rs = fs.createReadStream(src)\r\n  rs.on('error', err => cb(err)).once('open', () => {\r\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\r\n    ws.on('error', err => cb(err))\r\n      .on('open', () => rs.pipe(ws))\r\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\r\n  })\r\n}\r\n\r\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\r\n  fs.chmod(dest, srcStat.mode, err => {\r\n    if (err) return cb(err)\r\n    if (opts.preserveTimestamps) {\r\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\r\n    }\r\n    return cb()\r\n  })\r\n}\r\n\r\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\r\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)\r\n  if (destStat && !destStat.isDirectory()) {\r\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\r\n  }\r\n  return copyDir(src, dest, opts, cb)\r\n}\r\n\r\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\r\n  fs.mkdir(dest, err => {\r\n    if (err) return cb(err)\r\n    copyDir(src, dest, opts, err => {\r\n      if (err) return cb(err)\r\n      return fs.chmod(dest, srcStat.mode, cb)\r\n    })\r\n  })\r\n}\r\n\r\nfunction copyDir (src, dest, opts, cb) {\r\n  fs.readdir(src, (err, items) => {\r\n    if (err) return cb(err)\r\n    return copyDirItems(items, src, dest, opts, cb)\r\n  })\r\n}\r\n\r\nfunction copyDirItems (items, src, dest, opts, cb) {\r\n  const item = items.pop()\r\n  if (!item) return cb()\r\n  return copyDirItem(items, item, src, dest, opts, cb)\r\n}\r\n\r\nfunction copyDirItem (items, item, src, dest, opts, cb) {\r\n  const srcItem = path.join(src, item)\r\n  const destItem = path.join(dest, item)\r\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\r\n    if (err) return cb(err)\r\n    const { destStat } = stats\r\n    startCopy(destStat, srcItem, destItem, opts, err => {\r\n      if (err) return cb(err)\r\n      return copyDirItems(items, src, dest, opts, cb)\r\n    })\r\n  })\r\n}\r\n\r\nfunction onLink (destStat, src, dest, opts, cb) {\r\n  fs.readlink(src, (err, resolvedSrc) => {\r\n    if (err) return cb(err)\r\n    if (opts.dereference) {\r\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\r\n    }\r\n\r\n    if (!destStat) {\r\n      return fs.symlink(resolvedSrc, dest, cb)\r\n    } else {\r\n      fs.readlink(dest, (err, resolvedDest) => {\r\n        if (err) {\r\n          // dest exists and is a regular file or directory,\r\n          // Windows may throw UNKNOWN error. If dest already exists,\r\n          // fs throws error anyway, so no need to guard against it here.\r\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\r\n          return cb(err)\r\n        }\r\n        if (opts.dereference) {\r\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\r\n        }\r\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\r\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\r\n        }\r\n\r\n        // do not copy if src is a subdir of dest since unlinking\r\n        // dest in this case would result in removing src contents\r\n        // and therefore a broken symlink would be created.\r\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\r\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\r\n        }\r\n        return copyLink(resolvedSrc, dest, cb)\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\nfunction copyLink (resolvedSrc, dest, cb) {\r\n  fs.unlink(dest, err => {\r\n    if (err) return cb(err)\r\n    return fs.symlink(resolvedSrc, dest, cb)\r\n  })\r\n}\r\n\r\nmodule.exports = copy\r\n","\r\nconst u = require('universalify').fromPromise\r\nconst fs = require('../fs')\r\n\r\nfunction pathExists (path) {\r\n  return fs.access(path).then(() => true).catch(() => false)\r\n}\r\n\r\nmodule.exports = {\r\n  pathExists: u(pathExists),\r\n  pathExistsSync: fs.existsSync\r\n}\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst mkdir = require('../mkdirs')\r\nconst remove = require('../remove')\r\n\r\nconst emptyDir = u(function emptyDir (dir, callback) {\r\n  callback = callback || function () {}\r\n  fs.readdir(dir, (err, items) => {\r\n    if (err) return mkdir.mkdirs(dir, callback)\r\n\r\n    items = items.map(item => path.join(dir, item))\r\n\r\n    deleteItem()\r\n\r\n    function deleteItem () {\r\n      const item = items.pop()\r\n      if (!item) return callback()\r\n      remove.remove(item, err => {\r\n        if (err) return callback(err)\r\n        deleteItem()\r\n      })\r\n    }\r\n  })\r\n})\r\n\r\nfunction emptyDirSync (dir) {\r\n  let items\r\n  try {\r\n    items = fs.readdirSync(dir)\r\n  } catch (err) {\r\n    return mkdir.mkdirsSync(dir)\r\n  }\r\n\r\n  items.forEach(item => {\r\n    item = path.join(dir, item)\r\n    remove.removeSync(item)\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  emptyDirSync,\r\n  emptydirSync: emptyDirSync,\r\n  emptyDir,\r\n  emptydir: emptyDir\r\n}\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst rimraf = require('./rimraf')\r\n\r\nmodule.exports = {\r\n  remove: u(rimraf),\r\n  removeSync: rimraf.sync\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst assert = require('assert')\r\n\r\nconst isWindows = (process.platform === 'win32')\r\n\r\nfunction defaults (options) {\r\n  const methods = [\r\n    'unlink',\r\n    'chmod',\r\n    'stat',\r\n    'lstat',\r\n    'rmdir',\r\n    'readdir'\r\n  ]\r\n  methods.forEach(m => {\r\n    options[m] = options[m] || fs[m]\r\n    m = m + 'Sync'\r\n    options[m] = options[m] || fs[m]\r\n  })\r\n\r\n  options.maxBusyTries = options.maxBusyTries || 3\r\n}\r\n\r\nfunction rimraf (p, options, cb) {\r\n  let busyTries = 0\r\n\r\n  if (typeof options === 'function') {\r\n    cb = options\r\n    options = {}\r\n  }\r\n\r\n  assert(p, 'rimraf: missing path')\r\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\r\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\r\n  assert(options, 'rimraf: invalid options argument provided')\r\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\r\n\r\n  defaults(options)\r\n\r\n  rimraf_(p, options, function CB (er) {\r\n    if (er) {\r\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\r\n          busyTries < options.maxBusyTries) {\r\n        busyTries++\r\n        const time = busyTries * 100\r\n        // try again, with the same exact callback as this one.\r\n        return setTimeout(() => rimraf_(p, options, CB), time)\r\n      }\r\n\r\n      // already gone\r\n      if (er.code === 'ENOENT') er = null\r\n    }\r\n\r\n    cb(er)\r\n  })\r\n}\r\n\r\n// Two possible strategies.\r\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\r\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\r\n//\r\n// Both result in an extra syscall when you guess wrong.  However, there\r\n// are likely far more normal files in the world than directories.  This\r\n// is based on the assumption that a the average number of files per\r\n// directory is >= 1.\r\n//\r\n// If anyone ever complains about this, then I guess the strategy could\r\n// be made configurable somehow.  But until then, YAGNI.\r\nfunction rimraf_ (p, options, cb) {\r\n  assert(p)\r\n  assert(options)\r\n  assert(typeof cb === 'function')\r\n\r\n  // sunos lets the root user unlink directories, which is... weird.\r\n  // so we have to lstat here and make sure it's not a dir.\r\n  options.lstat(p, (er, st) => {\r\n    if (er && er.code === 'ENOENT') {\r\n      return cb(null)\r\n    }\r\n\r\n    // Windows can EPERM on stat.  Life is suffering.\r\n    if (er && er.code === 'EPERM' && isWindows) {\r\n      return fixWinEPERM(p, options, er, cb)\r\n    }\r\n\r\n    if (st && st.isDirectory()) {\r\n      return rmdir(p, options, er, cb)\r\n    }\r\n\r\n    options.unlink(p, er => {\r\n      if (er) {\r\n        if (er.code === 'ENOENT') {\r\n          return cb(null)\r\n        }\r\n        if (er.code === 'EPERM') {\r\n          return (isWindows)\r\n            ? fixWinEPERM(p, options, er, cb)\r\n            : rmdir(p, options, er, cb)\r\n        }\r\n        if (er.code === 'EISDIR') {\r\n          return rmdir(p, options, er, cb)\r\n        }\r\n      }\r\n      return cb(er)\r\n    })\r\n  })\r\n}\r\n\r\nfunction fixWinEPERM (p, options, er, cb) {\r\n  assert(p)\r\n  assert(options)\r\n  assert(typeof cb === 'function')\r\n  if (er) {\r\n    assert(er instanceof Error)\r\n  }\r\n\r\n  options.chmod(p, 0o666, er2 => {\r\n    if (er2) {\r\n      cb(er2.code === 'ENOENT' ? null : er)\r\n    } else {\r\n      options.stat(p, (er3, stats) => {\r\n        if (er3) {\r\n          cb(er3.code === 'ENOENT' ? null : er)\r\n        } else if (stats.isDirectory()) {\r\n          rmdir(p, options, er, cb)\r\n        } else {\r\n          options.unlink(p, cb)\r\n        }\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\nfunction fixWinEPERMSync (p, options, er) {\r\n  let stats\r\n\r\n  assert(p)\r\n  assert(options)\r\n  if (er) {\r\n    assert(er instanceof Error)\r\n  }\r\n\r\n  try {\r\n    options.chmodSync(p, 0o666)\r\n  } catch (er2) {\r\n    if (er2.code === 'ENOENT') {\r\n      return\r\n    } else {\r\n      throw er\r\n    }\r\n  }\r\n\r\n  try {\r\n    stats = options.statSync(p)\r\n  } catch (er3) {\r\n    if (er3.code === 'ENOENT') {\r\n      return\r\n    } else {\r\n      throw er\r\n    }\r\n  }\r\n\r\n  if (stats.isDirectory()) {\r\n    rmdirSync(p, options, er)\r\n  } else {\r\n    options.unlinkSync(p)\r\n  }\r\n}\r\n\r\nfunction rmdir (p, options, originalEr, cb) {\r\n  assert(p)\r\n  assert(options)\r\n  if (originalEr) {\r\n    assert(originalEr instanceof Error)\r\n  }\r\n  assert(typeof cb === 'function')\r\n\r\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\r\n  // if we guessed wrong, and it's not a directory, then\r\n  // raise the original error.\r\n  options.rmdir(p, er => {\r\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\r\n      rmkids(p, options, cb)\r\n    } else if (er && er.code === 'ENOTDIR') {\r\n      cb(originalEr)\r\n    } else {\r\n      cb(er)\r\n    }\r\n  })\r\n}\r\n\r\nfunction rmkids (p, options, cb) {\r\n  assert(p)\r\n  assert(options)\r\n  assert(typeof cb === 'function')\r\n\r\n  options.readdir(p, (er, files) => {\r\n    if (er) return cb(er)\r\n\r\n    let n = files.length\r\n    let errState\r\n\r\n    if (n === 0) return options.rmdir(p, cb)\r\n\r\n    files.forEach(f => {\r\n      rimraf(path.join(p, f), options, er => {\r\n        if (errState) {\r\n          return\r\n        }\r\n        if (er) return cb(errState = er)\r\n        if (--n === 0) {\r\n          options.rmdir(p, cb)\r\n        }\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\n// this looks simpler, and is strictly *faster*, but will\r\n// tie up the JavaScript thread and fail on excessively\r\n// deep directory trees.\r\nfunction rimrafSync (p, options) {\r\n  let st\r\n\r\n  options = options || {}\r\n  defaults(options)\r\n\r\n  assert(p, 'rimraf: missing path')\r\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\r\n  assert(options, 'rimraf: missing options')\r\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\r\n\r\n  try {\r\n    st = options.lstatSync(p)\r\n  } catch (er) {\r\n    if (er.code === 'ENOENT') {\r\n      return\r\n    }\r\n\r\n    // Windows can EPERM on stat.  Life is suffering.\r\n    if (er.code === 'EPERM' && isWindows) {\r\n      fixWinEPERMSync(p, options, er)\r\n    }\r\n  }\r\n\r\n  try {\r\n    // sunos lets the root user unlink directories, which is... weird.\r\n    if (st && st.isDirectory()) {\r\n      rmdirSync(p, options, null)\r\n    } else {\r\n      options.unlinkSync(p)\r\n    }\r\n  } catch (er) {\r\n    if (er.code === 'ENOENT') {\r\n      return\r\n    } else if (er.code === 'EPERM') {\r\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\r\n    } else if (er.code !== 'EISDIR') {\r\n      throw er\r\n    }\r\n    rmdirSync(p, options, er)\r\n  }\r\n}\r\n\r\nfunction rmdirSync (p, options, originalEr) {\r\n  assert(p)\r\n  assert(options)\r\n  if (originalEr) {\r\n    assert(originalEr instanceof Error)\r\n  }\r\n\r\n  try {\r\n    options.rmdirSync(p)\r\n  } catch (er) {\r\n    if (er.code === 'ENOTDIR') {\r\n      throw originalEr\r\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\r\n      rmkidsSync(p, options)\r\n    } else if (er.code !== 'ENOENT') {\r\n      throw er\r\n    }\r\n  }\r\n}\r\n\r\nfunction rmkidsSync (p, options) {\r\n  assert(p)\r\n  assert(options)\r\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\r\n\r\n  if (isWindows) {\r\n    // We only end up here once we got ENOTEMPTY at least once, and\r\n    // at this point, we are guaranteed to have removed all the kids.\r\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\r\n    // try really hard to delete stuff on windows, because it has a\r\n    // PROFOUNDLY annoying habit of not closing handles promptly when\r\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\r\n    const startTime = Date.now()\r\n    do {\r\n      try {\r\n        const ret = options.rmdirSync(p, options)\r\n        return ret\r\n      } catch (er) { }\r\n    } while (Date.now() - startTime < 500) // give up after 500ms\r\n  } else {\r\n    const ret = options.rmdirSync(p, options)\r\n    return ret\r\n  }\r\n}\r\n\r\nmodule.exports = rimraf\r\nrimraf.sync = rimrafSync\r\n","\r\n\r\nconst file = require('./file')\r\nconst link = require('./link')\r\nconst symlink = require('./symlink')\r\n\r\nmodule.exports = {\r\n  // file\r\n  createFile: file.createFile,\r\n  createFileSync: file.createFileSync,\r\n  ensureFile: file.createFile,\r\n  ensureFileSync: file.createFileSync,\r\n  // link\r\n  createLink: link.createLink,\r\n  createLinkSync: link.createLinkSync,\r\n  ensureLink: link.createLink,\r\n  ensureLinkSync: link.createLinkSync,\r\n  // symlink\r\n  createSymlink: symlink.createSymlink,\r\n  createSymlinkSync: symlink.createSymlinkSync,\r\n  ensureSymlink: symlink.createSymlink,\r\n  ensureSymlinkSync: symlink.createSymlinkSync\r\n}\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst path = require('path')\r\nconst fs = require('graceful-fs')\r\nconst mkdir = require('../mkdirs')\r\nconst pathExists = require('../path-exists').pathExists\r\n\r\nfunction createFile (file, callback) {\r\n  function makeFile () {\r\n    fs.writeFile(file, '', err => {\r\n      if (err) return callback(err)\r\n      callback()\r\n    })\r\n  }\r\n\r\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\r\n    if (!err && stats.isFile()) return callback()\r\n    const dir = path.dirname(file)\r\n    pathExists(dir, (err, dirExists) => {\r\n      if (err) return callback(err)\r\n      if (dirExists) return makeFile()\r\n      mkdir.mkdirs(dir, err => {\r\n        if (err) return callback(err)\r\n        makeFile()\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nfunction createFileSync (file) {\r\n  let stats\r\n  try {\r\n    stats = fs.statSync(file)\r\n  } catch (e) {}\r\n  if (stats && stats.isFile()) return\r\n\r\n  const dir = path.dirname(file)\r\n  if (!fs.existsSync(dir)) {\r\n    mkdir.mkdirsSync(dir)\r\n  }\r\n\r\n  fs.writeFileSync(file, '')\r\n}\r\n\r\nmodule.exports = {\r\n  createFile: u(createFile),\r\n  createFileSync\r\n}\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst path = require('path')\r\nconst fs = require('graceful-fs')\r\nconst mkdir = require('../mkdirs')\r\nconst pathExists = require('../path-exists').pathExists\r\n\r\nfunction createLink (srcpath, dstpath, callback) {\r\n  function makeLink (srcpath, dstpath) {\r\n    fs.link(srcpath, dstpath, err => {\r\n      if (err) return callback(err)\r\n      callback(null)\r\n    })\r\n  }\r\n\r\n  pathExists(dstpath, (err, destinationExists) => {\r\n    if (err) return callback(err)\r\n    if (destinationExists) return callback(null)\r\n    fs.lstat(srcpath, (err) => {\r\n      if (err) {\r\n        err.message = err.message.replace('lstat', 'ensureLink')\r\n        return callback(err)\r\n      }\r\n\r\n      const dir = path.dirname(dstpath)\r\n      pathExists(dir, (err, dirExists) => {\r\n        if (err) return callback(err)\r\n        if (dirExists) return makeLink(srcpath, dstpath)\r\n        mkdir.mkdirs(dir, err => {\r\n          if (err) return callback(err)\r\n          makeLink(srcpath, dstpath)\r\n        })\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nfunction createLinkSync (srcpath, dstpath) {\r\n  const destinationExists = fs.existsSync(dstpath)\r\n  if (destinationExists) return undefined\r\n\r\n  try {\r\n    fs.lstatSync(srcpath)\r\n  } catch (err) {\r\n    err.message = err.message.replace('lstat', 'ensureLink')\r\n    throw err\r\n  }\r\n\r\n  const dir = path.dirname(dstpath)\r\n  const dirExists = fs.existsSync(dir)\r\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\r\n  mkdir.mkdirsSync(dir)\r\n\r\n  return fs.linkSync(srcpath, dstpath)\r\n}\r\n\r\nmodule.exports = {\r\n  createLink: u(createLink),\r\n  createLinkSync\r\n}\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst path = require('path')\r\nconst fs = require('graceful-fs')\r\nconst _mkdirs = require('../mkdirs')\r\nconst mkdirs = _mkdirs.mkdirs\r\nconst mkdirsSync = _mkdirs.mkdirsSync\r\n\r\nconst _symlinkPaths = require('./symlink-paths')\r\nconst symlinkPaths = _symlinkPaths.symlinkPaths\r\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\r\n\r\nconst _symlinkType = require('./symlink-type')\r\nconst symlinkType = _symlinkType.symlinkType\r\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\r\n\r\nconst pathExists = require('../path-exists').pathExists\r\n\r\nfunction createSymlink (srcpath, dstpath, type, callback) {\r\n  callback = (typeof type === 'function') ? type : callback\r\n  type = (typeof type === 'function') ? false : type\r\n\r\n  pathExists(dstpath, (err, destinationExists) => {\r\n    if (err) return callback(err)\r\n    if (destinationExists) return callback(null)\r\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\r\n      if (err) return callback(err)\r\n      srcpath = relative.toDst\r\n      symlinkType(relative.toCwd, type, (err, type) => {\r\n        if (err) return callback(err)\r\n        const dir = path.dirname(dstpath)\r\n        pathExists(dir, (err, dirExists) => {\r\n          if (err) return callback(err)\r\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\r\n          mkdirs(dir, err => {\r\n            if (err) return callback(err)\r\n            fs.symlink(srcpath, dstpath, type, callback)\r\n          })\r\n        })\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nfunction createSymlinkSync (srcpath, dstpath, type) {\r\n  const destinationExists = fs.existsSync(dstpath)\r\n  if (destinationExists) return undefined\r\n\r\n  const relative = symlinkPathsSync(srcpath, dstpath)\r\n  srcpath = relative.toDst\r\n  type = symlinkTypeSync(relative.toCwd, type)\r\n  const dir = path.dirname(dstpath)\r\n  const exists = fs.existsSync(dir)\r\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\r\n  mkdirsSync(dir)\r\n  return fs.symlinkSync(srcpath, dstpath, type)\r\n}\r\n\r\nmodule.exports = {\r\n  createSymlink: u(createSymlink),\r\n  createSymlinkSync\r\n}\r\n","\r\n\r\nconst path = require('path')\r\nconst fs = require('graceful-fs')\r\nconst pathExists = require('../path-exists').pathExists\r\n\r\n/**\r\n * Function that returns two types of paths, one relative to symlink, and one\r\n * relative to the current working directory. Checks if path is absolute or\r\n * relative. If the path is relative, this function checks if the path is\r\n * relative to symlink or relative to current working directory. This is an\r\n * initiative to find a smarter `srcpath` to supply when building symlinks.\r\n * This allows you to determine which path to use out of one of three possible\r\n * types of source paths. The first is an absolute path. This is detected by\r\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\r\n * see if it exists. If it does it's used, if not an error is returned\r\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\r\n * relative url. By default Node's `fs.symlink` works by creating a symlink\r\n * using `dstpath` and expects the `srcpath` to be relative to the newly\r\n * created symlink. If you provide a `srcpath` that does not exist on the file\r\n * system it results in a broken symlink. To minimize this, the function\r\n * checks to see if the 'relative to symlink' source file exists, and if it\r\n * does it will use it. If it does not, it checks if there's a file that\r\n * exists that is relative to the current working directory, if does its used.\r\n * This preserves the expectations of the original fs.symlink spec and adds\r\n * the ability to pass in `relative to current working direcotry` paths.\r\n */\r\n\r\nfunction symlinkPaths (srcpath, dstpath, callback) {\r\n  if (path.isAbsolute(srcpath)) {\r\n    return fs.lstat(srcpath, (err) => {\r\n      if (err) {\r\n        err.message = err.message.replace('lstat', 'ensureSymlink')\r\n        return callback(err)\r\n      }\r\n      return callback(null, {\r\n        'toCwd': srcpath,\r\n        'toDst': srcpath\r\n      })\r\n    })\r\n  } else {\r\n    const dstdir = path.dirname(dstpath)\r\n    const relativeToDst = path.join(dstdir, srcpath)\r\n    return pathExists(relativeToDst, (err, exists) => {\r\n      if (err) return callback(err)\r\n      if (exists) {\r\n        return callback(null, {\r\n          'toCwd': relativeToDst,\r\n          'toDst': srcpath\r\n        })\r\n      } else {\r\n        return fs.lstat(srcpath, (err) => {\r\n          if (err) {\r\n            err.message = err.message.replace('lstat', 'ensureSymlink')\r\n            return callback(err)\r\n          }\r\n          return callback(null, {\r\n            'toCwd': srcpath,\r\n            'toDst': path.relative(dstdir, srcpath)\r\n          })\r\n        })\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction symlinkPathsSync (srcpath, dstpath) {\r\n  let exists\r\n  if (path.isAbsolute(srcpath)) {\r\n    exists = fs.existsSync(srcpath)\r\n    if (!exists) throw new Error('absolute srcpath does not exist')\r\n    return {\r\n      'toCwd': srcpath,\r\n      'toDst': srcpath\r\n    }\r\n  } else {\r\n    const dstdir = path.dirname(dstpath)\r\n    const relativeToDst = path.join(dstdir, srcpath)\r\n    exists = fs.existsSync(relativeToDst)\r\n    if (exists) {\r\n      return {\r\n        'toCwd': relativeToDst,\r\n        'toDst': srcpath\r\n      }\r\n    } else {\r\n      exists = fs.existsSync(srcpath)\r\n      if (!exists) throw new Error('relative srcpath does not exist')\r\n      return {\r\n        'toCwd': srcpath,\r\n        'toDst': path.relative(dstdir, srcpath)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  symlinkPaths,\r\n  symlinkPathsSync\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\n\r\nfunction symlinkType (srcpath, type, callback) {\r\n  callback = (typeof type === 'function') ? type : callback\r\n  type = (typeof type === 'function') ? false : type\r\n  if (type) return callback(null, type)\r\n  fs.lstat(srcpath, (err, stats) => {\r\n    if (err) return callback(null, 'file')\r\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\r\n    callback(null, type)\r\n  })\r\n}\r\n\r\nfunction symlinkTypeSync (srcpath, type) {\r\n  let stats\r\n\r\n  if (type) return type\r\n  try {\r\n    stats = fs.lstatSync(srcpath)\r\n  } catch (e) {\r\n    return 'file'\r\n  }\r\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\r\n}\r\n\r\nmodule.exports = {\r\n  symlinkType,\r\n  symlinkTypeSync\r\n}\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst jsonFile = require('./jsonfile')\r\n\r\njsonFile.outputJson = u(require('./output-json'))\r\njsonFile.outputJsonSync = require('./output-json-sync')\r\n// aliases\r\njsonFile.outputJSON = jsonFile.outputJson\r\njsonFile.outputJSONSync = jsonFile.outputJsonSync\r\njsonFile.writeJSON = jsonFile.writeJson\r\njsonFile.writeJSONSync = jsonFile.writeJsonSync\r\njsonFile.readJSON = jsonFile.readJson\r\njsonFile.readJSONSync = jsonFile.readJsonSync\r\n\r\nmodule.exports = jsonFile\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst jsonFile = require('jsonfile')\r\n\r\nmodule.exports = {\r\n  // jsonfile exports\r\n  readJson: u(jsonFile.readFile),\r\n  readJsonSync: jsonFile.readFileSync,\r\n  writeJson: u(jsonFile.writeFile),\r\n  writeJsonSync: jsonFile.writeFileSync\r\n}\r\n","\r\n\r\nconst path = require('path')\r\nconst mkdir = require('../mkdirs')\r\nconst pathExists = require('../path-exists').pathExists\r\nconst jsonFile = require('./jsonfile')\r\n\r\nfunction outputJson (file, data, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options\r\n    options = {}\r\n  }\r\n\r\n  const dir = path.dirname(file)\r\n\r\n  pathExists(dir, (err, itDoes) => {\r\n    if (err) return callback(err)\r\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\r\n\r\n    mkdir.mkdirs(dir, err => {\r\n      if (err) return callback(err)\r\n      jsonFile.writeJson(file, data, options, callback)\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = outputJson\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst mkdir = require('../mkdirs')\r\nconst jsonFile = require('./jsonfile')\r\n\r\nfunction outputJsonSync (file, data, options) {\r\n  const dir = path.dirname(file)\r\n\r\n  if (!fs.existsSync(dir)) {\r\n    mkdir.mkdirsSync(dir)\r\n  }\r\n\r\n  jsonFile.writeJsonSync(file, data, options)\r\n}\r\n\r\nmodule.exports = outputJsonSync\r\n","\r\n\r\nmodule.exports = {\r\n  moveSync: require('./move-sync')\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst copySync = require('../copy-sync').copySync\r\nconst removeSync = require('../remove').removeSync\r\nconst mkdirpSync = require('../mkdirs').mkdirpSync\r\nconst stat = require('../util/stat')\r\n\r\nfunction moveSync (src, dest, opts) {\r\n  opts = opts || {}\r\n  const overwrite = opts.overwrite || opts.clobber || false\r\n\r\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\r\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\r\n  mkdirpSync(path.dirname(dest))\r\n  return doRename(src, dest, overwrite)\r\n}\r\n\r\nfunction doRename (src, dest, overwrite) {\r\n  if (overwrite) {\r\n    removeSync(dest)\r\n    return rename(src, dest, overwrite)\r\n  }\r\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\r\n  return rename(src, dest, overwrite)\r\n}\r\n\r\nfunction rename (src, dest, overwrite) {\r\n  try {\r\n    fs.renameSync(src, dest)\r\n  } catch (err) {\r\n    if (err.code !== 'EXDEV') throw err\r\n    return moveAcrossDevice(src, dest, overwrite)\r\n  }\r\n}\r\n\r\nfunction moveAcrossDevice (src, dest, overwrite) {\r\n  const opts = {\r\n    overwrite,\r\n    errorOnExist: true\r\n  }\r\n  copySync(src, dest, opts)\r\n  return removeSync(src)\r\n}\r\n\r\nmodule.exports = moveSync\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nmodule.exports = {\r\n  move: u(require('./move'))\r\n}\r\n","\r\n\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst copy = require('../copy').copy\r\nconst remove = require('../remove').remove\r\nconst mkdirp = require('../mkdirs').mkdirp\r\nconst pathExists = require('../path-exists').pathExists\r\nconst stat = require('../util/stat')\r\n\r\nfunction move (src, dest, opts, cb) {\r\n  if (typeof opts === 'function') {\r\n    cb = opts\r\n    opts = {}\r\n  }\r\n\r\n  const overwrite = opts.overwrite || opts.clobber || false\r\n\r\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\r\n    if (err) return cb(err)\r\n    const { srcStat } = stats\r\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\r\n      if (err) return cb(err)\r\n      mkdirp(path.dirname(dest), err => {\r\n        if (err) return cb(err)\r\n        return doRename(src, dest, overwrite, cb)\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nfunction doRename (src, dest, overwrite, cb) {\r\n  if (overwrite) {\r\n    return remove(dest, err => {\r\n      if (err) return cb(err)\r\n      return rename(src, dest, overwrite, cb)\r\n    })\r\n  }\r\n  pathExists(dest, (err, destExists) => {\r\n    if (err) return cb(err)\r\n    if (destExists) return cb(new Error('dest already exists.'))\r\n    return rename(src, dest, overwrite, cb)\r\n  })\r\n}\r\n\r\nfunction rename (src, dest, overwrite, cb) {\r\n  fs.rename(src, dest, err => {\r\n    if (!err) return cb()\r\n    if (err.code !== 'EXDEV') return cb(err)\r\n    return moveAcrossDevice(src, dest, overwrite, cb)\r\n  })\r\n}\r\n\r\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\r\n  const opts = {\r\n    overwrite,\r\n    errorOnExist: true\r\n  }\r\n  copy(src, dest, opts, err => {\r\n    if (err) return cb(err)\r\n    return remove(src, cb)\r\n  })\r\n}\r\n\r\nmodule.exports = move\r\n","\r\n\r\nconst u = require('universalify').fromCallback\r\nconst fs = require('graceful-fs')\r\nconst path = require('path')\r\nconst mkdir = require('../mkdirs')\r\nconst pathExists = require('../path-exists').pathExists\r\n\r\nfunction outputFile (file, data, encoding, callback) {\r\n  if (typeof encoding === 'function') {\r\n    callback = encoding\r\n    encoding = 'utf8'\r\n  }\r\n\r\n  const dir = path.dirname(file)\r\n  pathExists(dir, (err, itDoes) => {\r\n    if (err) return callback(err)\r\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\r\n\r\n    mkdir.mkdirs(dir, err => {\r\n      if (err) return callback(err)\r\n\r\n      fs.writeFile(file, data, encoding, callback)\r\n    })\r\n  })\r\n}\r\n\r\nfunction outputFileSync (file, ...args) {\r\n  const dir = path.dirname(file)\r\n  if (fs.existsSync(dir)) {\r\n    return fs.writeFileSync(file, ...args)\r\n  }\r\n  mkdir.mkdirsSync(dir)\r\n  fs.writeFileSync(file, ...args)\r\n}\r\n\r\nmodule.exports = {\r\n  outputFile: u(outputFile),\r\n  outputFileSync\r\n}\r\n"]}