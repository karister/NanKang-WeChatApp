{"version":3,"sources":["graceful-fs.js","polyfills.js","legacy-streams.js","clone.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var fs = require('fs')\r\nvar polyfills = require('./polyfills.js')\r\nvar legacy = require('./legacy-streams.js')\r\nvar clone = require('./clone.js')\r\n\r\nvar util = require('util')\r\n\r\n/* istanbul ignore next - node 0.x polyfill */\r\nvar gracefulQueue\r\nvar previousSymbol\r\n\r\n/* istanbul ignore else - node 0.x polyfill */\r\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\r\n  gracefulQueue = Symbol.for('graceful-fs.queue')\r\n  // This is used in testing by future versions\r\n  previousSymbol = Symbol.for('graceful-fs.previous')\r\n} else {\r\n  gracefulQueue = '___graceful-fs.queue'\r\n  previousSymbol = '___graceful-fs.previous'\r\n}\r\n\r\nfunction noop () {}\r\n\r\nfunction publishQueue(context, queue) {\r\n  Object.defineProperty(context, gracefulQueue, {\r\n    get: function() {\r\n      return queue\r\n    }\r\n  })\r\n}\r\n\r\nvar debug = noop\r\nif (util.debuglog)\r\n  debug = util.debuglog('gfs4')\r\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\r\n  debug = function() {\r\n    var m = util.format.apply(util, arguments)\r\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\r\n    console.error(m)\r\n  }\r\n\r\n// Once time initialization\r\nif (!fs[gracefulQueue]) {\r\n  // This queue can be shared by multiple loaded instances\r\n  var queue = global[gracefulQueue] || []\r\n  publishQueue(fs, queue)\r\n\r\n  // Patch fs.close/closeSync to shared queue version, because we need\r\n  // to retry() whenever a close happens *anywhere* in the program.\r\n  // This is essential when multiple graceful-fs instances are\r\n  // in play at the same time.\r\n  fs.close = (function (fs$close) {\r\n    function close (fd, cb) {\r\n      return fs$close.call(fs, fd, function (err) {\r\n        // This function uses the graceful-fs shared queue\r\n        if (!err) {\r\n          resetQueue()\r\n        }\r\n\r\n        if (typeof cb === 'function')\r\n          cb.apply(this, arguments)\r\n      })\r\n    }\r\n\r\n    Object.defineProperty(close, previousSymbol, {\r\n      value: fs$close\r\n    })\r\n    return close\r\n  })(fs.close)\r\n\r\n  fs.closeSync = (function (fs$closeSync) {\r\n    function closeSync (fd) {\r\n      // This function uses the graceful-fs shared queue\r\n      fs$closeSync.apply(fs, arguments)\r\n      resetQueue()\r\n    }\r\n\r\n    Object.defineProperty(closeSync, previousSymbol, {\r\n      value: fs$closeSync\r\n    })\r\n    return closeSync\r\n  })(fs.closeSync)\r\n\r\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\r\n    process.on('exit', function() {\r\n      debug(fs[gracefulQueue])\r\n      require('assert').equal(fs[gracefulQueue].length, 0)\r\n    })\r\n  }\r\n}\r\n\r\nif (!global[gracefulQueue]) {\r\n  publishQueue(global, fs[gracefulQueue]);\r\n}\r\n\r\nmodule.exports = patch(clone(fs))\r\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\r\n    module.exports = patch(fs)\r\n    fs.__patched = true;\r\n}\r\n\r\nfunction patch (fs) {\r\n  // Everything that references the open() function needs to be in here\r\n  polyfills(fs)\r\n  fs.gracefulify = patch\r\n\r\n  fs.createReadStream = createReadStream\r\n  fs.createWriteStream = createWriteStream\r\n  var fs$readFile = fs.readFile\r\n  fs.readFile = readFile\r\n  function readFile (path, options, cb) {\r\n    if (typeof options === 'function')\r\n      cb = options, options = null\r\n\r\n    return go$readFile(path, options, cb)\r\n\r\n    function go$readFile (path, options, cb, startTime) {\r\n      return fs$readFile(path, options, function (err) {\r\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\r\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\r\n        else {\r\n          if (typeof cb === 'function')\r\n            cb.apply(this, arguments)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  var fs$writeFile = fs.writeFile\r\n  fs.writeFile = writeFile\r\n  function writeFile (path, data, options, cb) {\r\n    if (typeof options === 'function')\r\n      cb = options, options = null\r\n\r\n    return go$writeFile(path, data, options, cb)\r\n\r\n    function go$writeFile (path, data, options, cb, startTime) {\r\n      return fs$writeFile(path, data, options, function (err) {\r\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\r\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\r\n        else {\r\n          if (typeof cb === 'function')\r\n            cb.apply(this, arguments)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  var fs$appendFile = fs.appendFile\r\n  if (fs$appendFile)\r\n    fs.appendFile = appendFile\r\n  function appendFile (path, data, options, cb) {\r\n    if (typeof options === 'function')\r\n      cb = options, options = null\r\n\r\n    return go$appendFile(path, data, options, cb)\r\n\r\n    function go$appendFile (path, data, options, cb, startTime) {\r\n      return fs$appendFile(path, data, options, function (err) {\r\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\r\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\r\n        else {\r\n          if (typeof cb === 'function')\r\n            cb.apply(this, arguments)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  var fs$copyFile = fs.copyFile\r\n  if (fs$copyFile)\r\n    fs.copyFile = copyFile\r\n  function copyFile (src, dest, flags, cb) {\r\n    if (typeof flags === 'function') {\r\n      cb = flags\r\n      flags = 0\r\n    }\r\n    return go$copyFile(src, dest, flags, cb)\r\n\r\n    function go$copyFile (src, dest, flags, cb, startTime) {\r\n      return fs$copyFile(src, dest, flags, function (err) {\r\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\r\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\r\n        else {\r\n          if (typeof cb === 'function')\r\n            cb.apply(this, arguments)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  var fs$readdir = fs.readdir\r\n  fs.readdir = readdir\r\n  function readdir (path, options, cb) {\r\n    if (typeof options === 'function')\r\n      cb = options, options = null\r\n\r\n    return go$readdir(path, options, cb)\r\n\r\n    function go$readdir (path, options, cb, startTime) {\r\n      return fs$readdir(path, options, function (err, files) {\r\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\r\n          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()])\r\n        else {\r\n          if (files && files.sort)\r\n            files.sort()\r\n\r\n          if (typeof cb === 'function')\r\n            cb.call(this, err, files)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  if (process.version.substr(0, 4) === 'v0.8') {\r\n    var legStreams = legacy(fs)\r\n    ReadStream = legStreams.ReadStream\r\n    WriteStream = legStreams.WriteStream\r\n  }\r\n\r\n  var fs$ReadStream = fs.ReadStream\r\n  if (fs$ReadStream) {\r\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\r\n    ReadStream.prototype.open = ReadStream$open\r\n  }\r\n\r\n  var fs$WriteStream = fs.WriteStream\r\n  if (fs$WriteStream) {\r\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\r\n    WriteStream.prototype.open = WriteStream$open\r\n  }\r\n\r\n  Object.defineProperty(fs, 'ReadStream', {\r\n    get: function () {\r\n      return ReadStream\r\n    },\r\n    set: function (val) {\r\n      ReadStream = val\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  })\r\n  Object.defineProperty(fs, 'WriteStream', {\r\n    get: function () {\r\n      return WriteStream\r\n    },\r\n    set: function (val) {\r\n      WriteStream = val\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  })\r\n\r\n  // legacy names\r\n  var FileReadStream = ReadStream\r\n  Object.defineProperty(fs, 'FileReadStream', {\r\n    get: function () {\r\n      return FileReadStream\r\n    },\r\n    set: function (val) {\r\n      FileReadStream = val\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  })\r\n  var FileWriteStream = WriteStream\r\n  Object.defineProperty(fs, 'FileWriteStream', {\r\n    get: function () {\r\n      return FileWriteStream\r\n    },\r\n    set: function (val) {\r\n      FileWriteStream = val\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  })\r\n\r\n  function ReadStream (path, options) {\r\n    if (this instanceof ReadStream)\r\n      return fs$ReadStream.apply(this, arguments), this\r\n    else\r\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\r\n  }\r\n\r\n  function ReadStream$open () {\r\n    var that = this\r\n    open(that.path, that.flags, that.mode, function (err, fd) {\r\n      if (err) {\r\n        if (that.autoClose)\r\n          that.destroy()\r\n\r\n        that.emit('error', err)\r\n      } else {\r\n        that.fd = fd\r\n        that.emit('open', fd)\r\n        that.read()\r\n      }\r\n    })\r\n  }\r\n\r\n  function WriteStream (path, options) {\r\n    if (this instanceof WriteStream)\r\n      return fs$WriteStream.apply(this, arguments), this\r\n    else\r\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\r\n  }\r\n\r\n  function WriteStream$open () {\r\n    var that = this\r\n    open(that.path, that.flags, that.mode, function (err, fd) {\r\n      if (err) {\r\n        that.destroy()\r\n        that.emit('error', err)\r\n      } else {\r\n        that.fd = fd\r\n        that.emit('open', fd)\r\n      }\r\n    })\r\n  }\r\n\r\n  function createReadStream (path, options) {\r\n    return new fs.ReadStream(path, options)\r\n  }\r\n\r\n  function createWriteStream (path, options) {\r\n    return new fs.WriteStream(path, options)\r\n  }\r\n\r\n  var fs$open = fs.open\r\n  fs.open = open\r\n  function open (path, flags, mode, cb) {\r\n    if (typeof mode === 'function')\r\n      cb = mode, mode = null\r\n\r\n    return go$open(path, flags, mode, cb)\r\n\r\n    function go$open (path, flags, mode, cb, startTime) {\r\n      return fs$open(path, flags, mode, function (err, fd) {\r\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\r\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\r\n        else {\r\n          if (typeof cb === 'function')\r\n            cb.apply(this, arguments)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  return fs\r\n}\r\n\r\nfunction enqueue (elem) {\r\n  debug('ENQUEUE', elem[0].name, elem[1])\r\n  fs[gracefulQueue].push(elem)\r\n  retry()\r\n}\r\n\r\n// keep track of the timeout between retry() calls\r\nvar retryTimer\r\n\r\n// reset the startTime and lastTime to now\r\n// this resets the start of the 60 second overall timeout as well as the\r\n// delay between attempts so that we'll retry these jobs sooner\r\nfunction resetQueue () {\r\n  var now = Date.now()\r\n  for (var i = 0; i < fs[gracefulQueue].length; ++i) {\r\n    // entries that are only a length of 2 are from an older version, don't\r\n    // bother modifying those since they'll be retried anyway.\r\n    if (fs[gracefulQueue][i].length > 2) {\r\n      fs[gracefulQueue][i][3] = now // startTime\r\n      fs[gracefulQueue][i][4] = now // lastTime\r\n    }\r\n  }\r\n  // call retry to make sure we're actively processing the queue\r\n  retry()\r\n}\r\n\r\nfunction retry () {\r\n  // clear the timer and remove it to help prevent unintended concurrency\r\n  clearTimeout(retryTimer)\r\n  retryTimer = undefined\r\n\r\n  if (fs[gracefulQueue].length === 0)\r\n    return\r\n\r\n  var elem = fs[gracefulQueue].shift()\r\n  var fn = elem[0]\r\n  var args = elem[1]\r\n  // these items may be unset if they were added by an older graceful-fs\r\n  var err = elem[2]\r\n  var startTime = elem[3]\r\n  var lastTime = elem[4]\r\n\r\n  // if we don't have a startTime we have no way of knowing if we've waited\r\n  // long enough, so go ahead and retry this item now\r\n  if (startTime === undefined) {\r\n    debug('RETRY', fn.name, args)\r\n    fn.apply(null, args)\r\n  } else if (Date.now() - startTime >= 60000) {\r\n    // it's been more than 60 seconds total, bail now\r\n    debug('TIMEOUT', fn.name, args)\r\n    var cb = args.pop()\r\n    if (typeof cb === 'function')\r\n      cb.call(null, err)\r\n  } else {\r\n    // the amount of time between the last attempt and right now\r\n    var sinceAttempt = Date.now() - lastTime\r\n    // the amount of time between when we first tried, and when we last tried\r\n    // rounded up to at least 1\r\n    var sinceStart = Math.max(lastTime - startTime, 1)\r\n    // backoff. wait longer than the total time we've been retrying, but only\r\n    // up to a maximum of 100ms\r\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\r\n    // it's been long enough since the last retry, do it again\r\n    if (sinceAttempt >= desiredDelay) {\r\n      debug('RETRY', fn.name, args)\r\n      fn.apply(null, args.concat([startTime]))\r\n    } else {\r\n      // if we can't do this job yet, push it to the end of the queue\r\n      // and let the next iteration check again\r\n      fs[gracefulQueue].push(elem)\r\n    }\r\n  }\r\n\r\n  // schedule our next run if one isn't already scheduled\r\n  if (retryTimer === undefined) {\r\n    retryTimer = setTimeout(retry, 0)\r\n  }\r\n}\r\n","var constants = require('constants')\r\n\r\nvar origCwd = process.cwd\r\nvar cwd = null\r\n\r\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\r\n\r\nprocess.cwd = function() {\r\n  if (!cwd)\r\n    cwd = origCwd.call(process)\r\n  return cwd\r\n}\r\ntry {\r\n  process.cwd()\r\n} catch (er) {}\r\n\r\n// This check is needed until node.js 12 is required\r\nif (typeof process.chdir === 'function') {\r\n  var chdir = process.chdir\r\n  process.chdir = function (d) {\r\n    cwd = null\r\n    chdir.call(process, d)\r\n  }\r\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\r\n}\r\n\r\nmodule.exports = patch\r\n\r\nfunction patch (fs) {\r\n  // (re-)implement some things that are known busted or missing.\r\n\r\n  // lchmod, broken prior to 0.6.2\r\n  // back-port the fix here.\r\n  if (constants.hasOwnProperty('O_SYMLINK') &&\r\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\r\n    patchLchmod(fs)\r\n  }\r\n\r\n  // lutimes implementation, or no-op\r\n  if (!fs.lutimes) {\r\n    patchLutimes(fs)\r\n  }\r\n\r\n  // https://github.com/isaacs/node-graceful-fs/issues/4\r\n  // Chown should not fail on einval or eperm if non-root.\r\n  // It should not fail on enosys ever, as this just indicates\r\n  // that a fs doesn't support the intended operation.\r\n\r\n  fs.chown = chownFix(fs.chown)\r\n  fs.fchown = chownFix(fs.fchown)\r\n  fs.lchown = chownFix(fs.lchown)\r\n\r\n  fs.chmod = chmodFix(fs.chmod)\r\n  fs.fchmod = chmodFix(fs.fchmod)\r\n  fs.lchmod = chmodFix(fs.lchmod)\r\n\r\n  fs.chownSync = chownFixSync(fs.chownSync)\r\n  fs.fchownSync = chownFixSync(fs.fchownSync)\r\n  fs.lchownSync = chownFixSync(fs.lchownSync)\r\n\r\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\r\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\r\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\r\n\r\n  fs.stat = statFix(fs.stat)\r\n  fs.fstat = statFix(fs.fstat)\r\n  fs.lstat = statFix(fs.lstat)\r\n\r\n  fs.statSync = statFixSync(fs.statSync)\r\n  fs.fstatSync = statFixSync(fs.fstatSync)\r\n  fs.lstatSync = statFixSync(fs.lstatSync)\r\n\r\n  // if lchmod/lchown do not exist, then make them no-ops\r\n  if (!fs.lchmod) {\r\n    fs.lchmod = function (path, mode, cb) {\r\n      if (cb) process.nextTick(cb)\r\n    }\r\n    fs.lchmodSync = function () {}\r\n  }\r\n  if (!fs.lchown) {\r\n    fs.lchown = function (path, uid, gid, cb) {\r\n      if (cb) process.nextTick(cb)\r\n    }\r\n    fs.lchownSync = function () {}\r\n  }\r\n\r\n  // on Windows, A/V software can lock the directory, causing this\r\n  // to fail with an EACCES or EPERM if the directory contains newly\r\n  // created files.  Try again on failure, for up to 60 seconds.\r\n\r\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\r\n  // bit9, may lock files for up to a minute, causing npm package install\r\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\r\n  // CPU to a busy looping process, which can cause the program causing the lock\r\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\r\n  if (platform === \"win32\") {\r\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\r\n      var start = Date.now()\r\n      var backoff = 0;\r\n      fs$rename(from, to, function CB (er) {\r\n        if (er\r\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\r\n            && Date.now() - start < 60000) {\r\n          setTimeout(function() {\r\n            fs.stat(to, function (stater, st) {\r\n              if (stater && stater.code === \"ENOENT\")\r\n                fs$rename(from, to, CB);\r\n              else\r\n                cb(er)\r\n            })\r\n          }, backoff)\r\n          if (backoff < 100)\r\n            backoff += 10;\r\n          return;\r\n        }\r\n        if (cb) cb(er)\r\n      })\r\n    }})(fs.rename)\r\n  }\r\n\r\n  // if read() returns EAGAIN, then just try it again.\r\n  fs.read = (function (fs$read) {\r\n    function read (fd, buffer, offset, length, position, callback_) {\r\n      var callback\r\n      if (callback_ && typeof callback_ === 'function') {\r\n        var eagCounter = 0\r\n        callback = function (er, _, __) {\r\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\r\n            eagCounter ++\r\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\r\n          }\r\n          callback_.apply(this, arguments)\r\n        }\r\n      }\r\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\r\n    }\r\n\r\n    // This ensures `util.promisify` works as it does for native `fs.read`.\r\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\r\n    return read\r\n  })(fs.read)\r\n\r\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\r\n    var eagCounter = 0\r\n    while (true) {\r\n      try {\r\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\r\n      } catch (er) {\r\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\r\n          eagCounter ++\r\n          continue\r\n        }\r\n        throw er\r\n      }\r\n    }\r\n  }})(fs.readSync)\r\n\r\n  function patchLchmod (fs) {\r\n    fs.lchmod = function (path, mode, callback) {\r\n      fs.open( path\r\n             , constants.O_WRONLY | constants.O_SYMLINK\r\n             , mode\r\n             , function (err, fd) {\r\n        if (err) {\r\n          if (callback) callback(err)\r\n          return\r\n        }\r\n        // prefer to return the chmod error, if one occurs,\r\n        // but still try to close, and report closing errors if they occur.\r\n        fs.fchmod(fd, mode, function (err) {\r\n          fs.close(fd, function(err2) {\r\n            if (callback) callback(err || err2)\r\n          })\r\n        })\r\n      })\r\n    }\r\n\r\n    fs.lchmodSync = function (path, mode) {\r\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\r\n\r\n      // prefer to return the chmod error, if one occurs,\r\n      // but still try to close, and report closing errors if they occur.\r\n      var threw = true\r\n      var ret\r\n      try {\r\n        ret = fs.fchmodSync(fd, mode)\r\n        threw = false\r\n      } finally {\r\n        if (threw) {\r\n          try {\r\n            fs.closeSync(fd)\r\n          } catch (er) {}\r\n        } else {\r\n          fs.closeSync(fd)\r\n        }\r\n      }\r\n      return ret\r\n    }\r\n  }\r\n\r\n  function patchLutimes (fs) {\r\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\r\n      fs.lutimes = function (path, at, mt, cb) {\r\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\r\n          if (er) {\r\n            if (cb) cb(er)\r\n            return\r\n          }\r\n          fs.futimes(fd, at, mt, function (er) {\r\n            fs.close(fd, function (er2) {\r\n              if (cb) cb(er || er2)\r\n            })\r\n          })\r\n        })\r\n      }\r\n\r\n      fs.lutimesSync = function (path, at, mt) {\r\n        var fd = fs.openSync(path, constants.O_SYMLINK)\r\n        var ret\r\n        var threw = true\r\n        try {\r\n          ret = fs.futimesSync(fd, at, mt)\r\n          threw = false\r\n        } finally {\r\n          if (threw) {\r\n            try {\r\n              fs.closeSync(fd)\r\n            } catch (er) {}\r\n          } else {\r\n            fs.closeSync(fd)\r\n          }\r\n        }\r\n        return ret\r\n      }\r\n\r\n    } else {\r\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\r\n      fs.lutimesSync = function () {}\r\n    }\r\n  }\r\n\r\n  function chmodFix (orig) {\r\n    if (!orig) return orig\r\n    return function (target, mode, cb) {\r\n      return orig.call(fs, target, mode, function (er) {\r\n        if (chownErOk(er)) er = null\r\n        if (cb) cb.apply(this, arguments)\r\n      })\r\n    }\r\n  }\r\n\r\n  function chmodFixSync (orig) {\r\n    if (!orig) return orig\r\n    return function (target, mode) {\r\n      try {\r\n        return orig.call(fs, target, mode)\r\n      } catch (er) {\r\n        if (!chownErOk(er)) throw er\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  function chownFix (orig) {\r\n    if (!orig) return orig\r\n    return function (target, uid, gid, cb) {\r\n      return orig.call(fs, target, uid, gid, function (er) {\r\n        if (chownErOk(er)) er = null\r\n        if (cb) cb.apply(this, arguments)\r\n      })\r\n    }\r\n  }\r\n\r\n  function chownFixSync (orig) {\r\n    if (!orig) return orig\r\n    return function (target, uid, gid) {\r\n      try {\r\n        return orig.call(fs, target, uid, gid)\r\n      } catch (er) {\r\n        if (!chownErOk(er)) throw er\r\n      }\r\n    }\r\n  }\r\n\r\n  function statFix (orig) {\r\n    if (!orig) return orig\r\n    // Older versions of Node erroneously returned signed integers for\r\n    // uid + gid.\r\n    return function (target, options, cb) {\r\n      if (typeof options === 'function') {\r\n        cb = options\r\n        options = null\r\n      }\r\n      function callback (er, stats) {\r\n        if (stats) {\r\n          if (stats.uid < 0) stats.uid += 0x100000000\r\n          if (stats.gid < 0) stats.gid += 0x100000000\r\n        }\r\n        if (cb) cb.apply(this, arguments)\r\n      }\r\n      return options ? orig.call(fs, target, options, callback)\r\n        : orig.call(fs, target, callback)\r\n    }\r\n  }\r\n\r\n  function statFixSync (orig) {\r\n    if (!orig) return orig\r\n    // Older versions of Node erroneously returned signed integers for\r\n    // uid + gid.\r\n    return function (target, options) {\r\n      var stats = options ? orig.call(fs, target, options)\r\n        : orig.call(fs, target)\r\n      if (stats.uid < 0) stats.uid += 0x100000000\r\n      if (stats.gid < 0) stats.gid += 0x100000000\r\n      return stats;\r\n    }\r\n  }\r\n\r\n  // ENOSYS means that the fs doesn't support the op. Just ignore\r\n  // that, because it doesn't matter.\r\n  //\r\n  // if there's no getuid, or if getuid() is something other\r\n  // than 0, and the error is EINVAL or EPERM, then just ignore\r\n  // it.\r\n  //\r\n  // This specific case is a silent failure in cp, install, tar,\r\n  // and most other unix tools that manage permissions.\r\n  //\r\n  // When running as root, or if other types of errors are\r\n  // encountered, then it's strict.\r\n  function chownErOk (er) {\r\n    if (!er)\r\n      return true\r\n\r\n    if (er.code === \"ENOSYS\")\r\n      return true\r\n\r\n    var nonroot = !process.getuid || process.getuid() !== 0\r\n    if (nonroot) {\r\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\r\n        return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n","var Stream = require('stream').Stream\r\n\r\nmodule.exports = legacy\r\n\r\nfunction legacy (fs) {\r\n  return {\r\n    ReadStream: ReadStream,\r\n    WriteStream: WriteStream\r\n  }\r\n\r\n  function ReadStream (path, options) {\r\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\r\n\r\n    Stream.call(this);\r\n\r\n    var self = this;\r\n\r\n    this.path = path;\r\n    this.fd = null;\r\n    this.readable = true;\r\n    this.paused = false;\r\n\r\n    this.flags = 'r';\r\n    this.mode = 438; /*=0666*/\r\n    this.bufferSize = 64 * 1024;\r\n\r\n    options = options || {};\r\n\r\n    // Mixin options into this\r\n    var keys = Object.keys(options);\r\n    for (var index = 0, length = keys.length; index < length; index++) {\r\n      var key = keys[index];\r\n      this[key] = options[key];\r\n    }\r\n\r\n    if (this.encoding) this.setEncoding(this.encoding);\r\n\r\n    if (this.start !== undefined) {\r\n      if ('number' !== typeof this.start) {\r\n        throw TypeError('start must be a Number');\r\n      }\r\n      if (this.end === undefined) {\r\n        this.end = Infinity;\r\n      } else if ('number' !== typeof this.end) {\r\n        throw TypeError('end must be a Number');\r\n      }\r\n\r\n      if (this.start > this.end) {\r\n        throw new Error('start must be <= end');\r\n      }\r\n\r\n      this.pos = this.start;\r\n    }\r\n\r\n    if (this.fd !== null) {\r\n      process.nextTick(function() {\r\n        self._read();\r\n      });\r\n      return;\r\n    }\r\n\r\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\r\n      if (err) {\r\n        self.emit('error', err);\r\n        self.readable = false;\r\n        return;\r\n      }\r\n\r\n      self.fd = fd;\r\n      self.emit('open', fd);\r\n      self._read();\r\n    })\r\n  }\r\n\r\n  function WriteStream (path, options) {\r\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\r\n\r\n    Stream.call(this);\r\n\r\n    this.path = path;\r\n    this.fd = null;\r\n    this.writable = true;\r\n\r\n    this.flags = 'w';\r\n    this.encoding = 'binary';\r\n    this.mode = 438; /*=0666*/\r\n    this.bytesWritten = 0;\r\n\r\n    options = options || {};\r\n\r\n    // Mixin options into this\r\n    var keys = Object.keys(options);\r\n    for (var index = 0, length = keys.length; index < length; index++) {\r\n      var key = keys[index];\r\n      this[key] = options[key];\r\n    }\r\n\r\n    if (this.start !== undefined) {\r\n      if ('number' !== typeof this.start) {\r\n        throw TypeError('start must be a Number');\r\n      }\r\n      if (this.start < 0) {\r\n        throw new Error('start must be >= zero');\r\n      }\r\n\r\n      this.pos = this.start;\r\n    }\r\n\r\n    this.busy = false;\r\n    this._queue = [];\r\n\r\n    if (this.fd === null) {\r\n      this._open = fs.open;\r\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\r\n      this.flush();\r\n    }\r\n  }\r\n}\r\n","\r\n\r\nmodule.exports = clone\r\n\r\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\r\n  return obj.__proto__\r\n}\r\n\r\nfunction clone (obj) {\r\n  if (obj === null || typeof obj !== 'object')\r\n    return obj\r\n\r\n  if (obj instanceof Object)\r\n    var copy = { __proto__: getPrototypeOf(obj) }\r\n  else\r\n    var copy = Object.create(null)\r\n\r\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\r\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\r\n  })\r\n\r\n  return copy\r\n}\r\n"]}