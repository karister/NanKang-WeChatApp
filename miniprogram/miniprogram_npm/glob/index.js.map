{"version":3,"sources":["glob.js","sync.js","common.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// Approach:\r\n//\r\n// 1. Get the minimatch set\r\n// 2. For each pattern in the set, PROCESS(pattern, false)\r\n// 3. Store matches per-set, then uniq them\r\n//\r\n// PROCESS(pattern, inGlobStar)\r\n// Get the first [n] items from pattern that are all strings\r\n// Join these together.  This is PREFIX.\r\n//   If there is no more remaining, then stat(PREFIX) and\r\n//   add to matches if it succeeds.  END.\r\n//\r\n// If inGlobStar and PREFIX is symlink and points to dir\r\n//   set ENTRIES = []\r\n// else readdir(PREFIX) as ENTRIES\r\n//   If fail, END\r\n//\r\n// with ENTRIES\r\n//   If pattern[n] is GLOBSTAR\r\n//     // handle the case where the globstar match is empty\r\n//     // by pruning it out, and testing the resulting pattern\r\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\r\n//     // handle other cases.\r\n//     for ENTRY in ENTRIES (not dotfiles)\r\n//       // attach globstar + tail onto the entry\r\n//       // Mark that this entry is a globstar match\r\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\r\n//\r\n//   else // not globstar\r\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\r\n//       Test ENTRY against pattern[n]\r\n//       If fails, continue\r\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\r\n//\r\n// Caveat:\r\n//   Cache all stats and readdirs results to minimize syscall.  Since all\r\n//   we ever care about is existence and directory-ness, we can just keep\r\n//   `true` for files, and [children,...] for directories, or `false` for\r\n//   things that don't exist.\r\n\r\nmodule.exports = glob\r\n\r\nvar rp = require('fs.realpath')\r\nvar minimatch = require('minimatch')\r\nvar Minimatch = minimatch.Minimatch\r\nvar inherits = require('inherits')\r\nvar EE = require('events').EventEmitter\r\nvar path = require('path')\r\nvar assert = require('assert')\r\nvar isAbsolute = require('path-is-absolute')\r\nvar globSync = require('./sync.js')\r\nvar common = require('./common.js')\r\nvar setopts = common.setopts\r\nvar ownProp = common.ownProp\r\nvar inflight = require('inflight')\r\nvar util = require('util')\r\nvar childrenIgnored = common.childrenIgnored\r\nvar isIgnored = common.isIgnored\r\n\r\nvar once = require('once')\r\n\r\nfunction glob (pattern, options, cb) {\r\n  if (typeof options === 'function') cb = options, options = {}\r\n  if (!options) options = {}\r\n\r\n  if (options.sync) {\r\n    if (cb)\r\n      throw new TypeError('callback provided to sync glob')\r\n    return globSync(pattern, options)\r\n  }\r\n\r\n  return new Glob(pattern, options, cb)\r\n}\r\n\r\nglob.sync = globSync\r\nvar GlobSync = glob.GlobSync = globSync.GlobSync\r\n\r\n// old api surface\r\nglob.glob = glob\r\n\r\nfunction extend (origin, add) {\r\n  if (add === null || typeof add !== 'object') {\r\n    return origin\r\n  }\r\n\r\n  var keys = Object.keys(add)\r\n  var i = keys.length\r\n  while (i--) {\r\n    origin[keys[i]] = add[keys[i]]\r\n  }\r\n  return origin\r\n}\r\n\r\nglob.hasMagic = function (pattern, options_) {\r\n  var options = extend({}, options_)\r\n  options.noprocess = true\r\n\r\n  var g = new Glob(pattern, options)\r\n  var set = g.minimatch.set\r\n\r\n  if (!pattern)\r\n    return false\r\n\r\n  if (set.length > 1)\r\n    return true\r\n\r\n  for (var j = 0; j < set[0].length; j++) {\r\n    if (typeof set[0][j] !== 'string')\r\n      return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nglob.Glob = Glob\r\ninherits(Glob, EE)\r\nfunction Glob (pattern, options, cb) {\r\n  if (typeof options === 'function') {\r\n    cb = options\r\n    options = null\r\n  }\r\n\r\n  if (options && options.sync) {\r\n    if (cb)\r\n      throw new TypeError('callback provided to sync glob')\r\n    return new GlobSync(pattern, options)\r\n  }\r\n\r\n  if (!(this instanceof Glob))\r\n    return new Glob(pattern, options, cb)\r\n\r\n  setopts(this, pattern, options)\r\n  this._didRealPath = false\r\n\r\n  // process each pattern in the minimatch set\r\n  var n = this.minimatch.set.length\r\n\r\n  // The matches are stored as {<filename>: true,...} so that\r\n  // duplicates are automagically pruned.\r\n  // Later, we do an Object.keys() on these.\r\n  // Keep them as a list so we can fill in when nonull is set.\r\n  this.matches = new Array(n)\r\n\r\n  if (typeof cb === 'function') {\r\n    cb = once(cb)\r\n    this.on('error', cb)\r\n    this.on('end', function (matches) {\r\n      cb(null, matches)\r\n    })\r\n  }\r\n\r\n  var self = this\r\n  this._processing = 0\r\n\r\n  this._emitQueue = []\r\n  this._processQueue = []\r\n  this.paused = false\r\n\r\n  if (this.noprocess)\r\n    return this\r\n\r\n  if (n === 0)\r\n    return done()\r\n\r\n  var sync = true\r\n  for (var i = 0; i < n; i ++) {\r\n    this._process(this.minimatch.set[i], i, false, done)\r\n  }\r\n  sync = false\r\n\r\n  function done () {\r\n    --self._processing\r\n    if (self._processing <= 0) {\r\n      if (sync) {\r\n        process.nextTick(function () {\r\n          self._finish()\r\n        })\r\n      } else {\r\n        self._finish()\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nGlob.prototype._finish = function () {\r\n  assert(this instanceof Glob)\r\n  if (this.aborted)\r\n    return\r\n\r\n  if (this.realpath && !this._didRealpath)\r\n    return this._realpath()\r\n\r\n  common.finish(this)\r\n  this.emit('end', this.found)\r\n}\r\n\r\nGlob.prototype._realpath = function () {\r\n  if (this._didRealpath)\r\n    return\r\n\r\n  this._didRealpath = true\r\n\r\n  var n = this.matches.length\r\n  if (n === 0)\r\n    return this._finish()\r\n\r\n  var self = this\r\n  for (var i = 0; i < this.matches.length; i++)\r\n    this._realpathSet(i, next)\r\n\r\n  function next () {\r\n    if (--n === 0)\r\n      self._finish()\r\n  }\r\n}\r\n\r\nGlob.prototype._realpathSet = function (index, cb) {\r\n  var matchset = this.matches[index]\r\n  if (!matchset)\r\n    return cb()\r\n\r\n  var found = Object.keys(matchset)\r\n  var self = this\r\n  var n = found.length\r\n\r\n  if (n === 0)\r\n    return cb()\r\n\r\n  var set = this.matches[index] = Object.create(null)\r\n  found.forEach(function (p, i) {\r\n    // If there's a problem with the stat, then it means that\r\n    // one or more of the links in the realpath couldn't be\r\n    // resolved.  just return the abs value in that case.\r\n    p = self._makeAbs(p)\r\n    rp.realpath(p, self.realpathCache, function (er, real) {\r\n      if (!er)\r\n        set[real] = true\r\n      else if (er.syscall === 'stat')\r\n        set[p] = true\r\n      else\r\n        self.emit('error', er) // srsly wtf right here\r\n\r\n      if (--n === 0) {\r\n        self.matches[index] = set\r\n        cb()\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nGlob.prototype._mark = function (p) {\r\n  return common.mark(this, p)\r\n}\r\n\r\nGlob.prototype._makeAbs = function (f) {\r\n  return common.makeAbs(this, f)\r\n}\r\n\r\nGlob.prototype.abort = function () {\r\n  this.aborted = true\r\n  this.emit('abort')\r\n}\r\n\r\nGlob.prototype.pause = function () {\r\n  if (!this.paused) {\r\n    this.paused = true\r\n    this.emit('pause')\r\n  }\r\n}\r\n\r\nGlob.prototype.resume = function () {\r\n  if (this.paused) {\r\n    this.emit('resume')\r\n    this.paused = false\r\n    if (this._emitQueue.length) {\r\n      var eq = this._emitQueue.slice(0)\r\n      this._emitQueue.length = 0\r\n      for (var i = 0; i < eq.length; i ++) {\r\n        var e = eq[i]\r\n        this._emitMatch(e[0], e[1])\r\n      }\r\n    }\r\n    if (this._processQueue.length) {\r\n      var pq = this._processQueue.slice(0)\r\n      this._processQueue.length = 0\r\n      for (var i = 0; i < pq.length; i ++) {\r\n        var p = pq[i]\r\n        this._processing--\r\n        this._process(p[0], p[1], p[2], p[3])\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\r\n  assert(this instanceof Glob)\r\n  assert(typeof cb === 'function')\r\n\r\n  if (this.aborted)\r\n    return\r\n\r\n  this._processing++\r\n  if (this.paused) {\r\n    this._processQueue.push([pattern, index, inGlobStar, cb])\r\n    return\r\n  }\r\n\r\n  //console.error('PROCESS %d', this._processing, pattern)\r\n\r\n  // Get the first [n] parts of pattern that are all strings.\r\n  var n = 0\r\n  while (typeof pattern[n] === 'string') {\r\n    n ++\r\n  }\r\n  // now n is the index of the first one that is *not* a string.\r\n\r\n  // see if there's anything else\r\n  var prefix\r\n  switch (n) {\r\n    // if not, then this is rather simple\r\n    case pattern.length:\r\n      this._processSimple(pattern.join('/'), index, cb)\r\n      return\r\n\r\n    case 0:\r\n      // pattern *starts* with some non-trivial item.\r\n      // going to readdir(cwd), but not include the prefix in matches.\r\n      prefix = null\r\n      break\r\n\r\n    default:\r\n      // pattern has some string bits in the front.\r\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\r\n      // or 'relative' like '../baz'\r\n      prefix = pattern.slice(0, n).join('/')\r\n      break\r\n  }\r\n\r\n  var remain = pattern.slice(n)\r\n\r\n  // get the list of entries.\r\n  var read\r\n  if (prefix === null)\r\n    read = '.'\r\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\r\n    if (!prefix || !isAbsolute(prefix))\r\n      prefix = '/' + prefix\r\n    read = prefix\r\n  } else\r\n    read = prefix\r\n\r\n  var abs = this._makeAbs(read)\r\n\r\n  //if ignored, skip _processing\r\n  if (childrenIgnored(this, read))\r\n    return cb()\r\n\r\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\r\n  if (isGlobStar)\r\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\r\n  else\r\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\r\n}\r\n\r\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\r\n  var self = this\r\n  this._readdir(abs, inGlobStar, function (er, entries) {\r\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\r\n  })\r\n}\r\n\r\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\r\n\r\n  // if the abs isn't a dir, then nothing can match!\r\n  if (!entries)\r\n    return cb()\r\n\r\n  // It will only match dot entries if it starts with a dot, or if\r\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\r\n  var pn = remain[0]\r\n  var negate = !!this.minimatch.negate\r\n  var rawGlob = pn._glob\r\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\r\n\r\n  var matchedEntries = []\r\n  for (var i = 0; i < entries.length; i++) {\r\n    var e = entries[i]\r\n    if (e.charAt(0) !== '.' || dotOk) {\r\n      var m\r\n      if (negate && !prefix) {\r\n        m = !e.match(pn)\r\n      } else {\r\n        m = e.match(pn)\r\n      }\r\n      if (m)\r\n        matchedEntries.push(e)\r\n    }\r\n  }\r\n\r\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\r\n\r\n  var len = matchedEntries.length\r\n  // If there are no matched entries, then nothing matches.\r\n  if (len === 0)\r\n    return cb()\r\n\r\n  // if this is the last remaining pattern bit, then no need for\r\n  // an additional stat *unless* the user has specified mark or\r\n  // stat explicitly.  We know they exist, since readdir returned\r\n  // them.\r\n\r\n  if (remain.length === 1 && !this.mark && !this.stat) {\r\n    if (!this.matches[index])\r\n      this.matches[index] = Object.create(null)\r\n\r\n    for (var i = 0; i < len; i ++) {\r\n      var e = matchedEntries[i]\r\n      if (prefix) {\r\n        if (prefix !== '/')\r\n          e = prefix + '/' + e\r\n        else\r\n          e = prefix + e\r\n      }\r\n\r\n      if (e.charAt(0) === '/' && !this.nomount) {\r\n        e = path.join(this.root, e)\r\n      }\r\n      this._emitMatch(index, e)\r\n    }\r\n    // This was the last one, and no stats were needed\r\n    return cb()\r\n  }\r\n\r\n  // now test all matched entries as stand-ins for that part\r\n  // of the pattern.\r\n  remain.shift()\r\n  for (var i = 0; i < len; i ++) {\r\n    var e = matchedEntries[i]\r\n    var newPattern\r\n    if (prefix) {\r\n      if (prefix !== '/')\r\n        e = prefix + '/' + e\r\n      else\r\n        e = prefix + e\r\n    }\r\n    this._process([e].concat(remain), index, inGlobStar, cb)\r\n  }\r\n  cb()\r\n}\r\n\r\nGlob.prototype._emitMatch = function (index, e) {\r\n  if (this.aborted)\r\n    return\r\n\r\n  if (isIgnored(this, e))\r\n    return\r\n\r\n  if (this.paused) {\r\n    this._emitQueue.push([index, e])\r\n    return\r\n  }\r\n\r\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\r\n\r\n  if (this.mark)\r\n    e = this._mark(e)\r\n\r\n  if (this.absolute)\r\n    e = abs\r\n\r\n  if (this.matches[index][e])\r\n    return\r\n\r\n  if (this.nodir) {\r\n    var c = this.cache[abs]\r\n    if (c === 'DIR' || Array.isArray(c))\r\n      return\r\n  }\r\n\r\n  this.matches[index][e] = true\r\n\r\n  var st = this.statCache[abs]\r\n  if (st)\r\n    this.emit('stat', e, st)\r\n\r\n  this.emit('match', e)\r\n}\r\n\r\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\r\n  if (this.aborted)\r\n    return\r\n\r\n  // follow all symlinked directories forever\r\n  // just proceed as if this is a non-globstar situation\r\n  if (this.follow)\r\n    return this._readdir(abs, false, cb)\r\n\r\n  var lstatkey = 'lstat\\0' + abs\r\n  var self = this\r\n  var lstatcb = inflight(lstatkey, lstatcb_)\r\n\r\n  if (lstatcb)\r\n    self.fs.lstat(abs, lstatcb)\r\n\r\n  function lstatcb_ (er, lstat) {\r\n    if (er && er.code === 'ENOENT')\r\n      return cb()\r\n\r\n    var isSym = lstat && lstat.isSymbolicLink()\r\n    self.symlinks[abs] = isSym\r\n\r\n    // If it's not a symlink or a dir, then it's definitely a regular file.\r\n    // don't bother doing a readdir in that case.\r\n    if (!isSym && lstat && !lstat.isDirectory()) {\r\n      self.cache[abs] = 'FILE'\r\n      cb()\r\n    } else\r\n      self._readdir(abs, false, cb)\r\n  }\r\n}\r\n\r\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\r\n  if (this.aborted)\r\n    return\r\n\r\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\r\n  if (!cb)\r\n    return\r\n\r\n  //console.error('RD %j %j', +inGlobStar, abs)\r\n  if (inGlobStar && !ownProp(this.symlinks, abs))\r\n    return this._readdirInGlobStar(abs, cb)\r\n\r\n  if (ownProp(this.cache, abs)) {\r\n    var c = this.cache[abs]\r\n    if (!c || c === 'FILE')\r\n      return cb()\r\n\r\n    if (Array.isArray(c))\r\n      return cb(null, c)\r\n  }\r\n\r\n  var self = this\r\n  self.fs.readdir(abs, readdirCb(this, abs, cb))\r\n}\r\n\r\nfunction readdirCb (self, abs, cb) {\r\n  return function (er, entries) {\r\n    if (er)\r\n      self._readdirError(abs, er, cb)\r\n    else\r\n      self._readdirEntries(abs, entries, cb)\r\n  }\r\n}\r\n\r\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\r\n  if (this.aborted)\r\n    return\r\n\r\n  // if we haven't asked to stat everything, then just\r\n  // assume that everything in there exists, so we can avoid\r\n  // having to stat it a second time.\r\n  if (!this.mark && !this.stat) {\r\n    for (var i = 0; i < entries.length; i ++) {\r\n      var e = entries[i]\r\n      if (abs === '/')\r\n        e = abs + e\r\n      else\r\n        e = abs + '/' + e\r\n      this.cache[e] = true\r\n    }\r\n  }\r\n\r\n  this.cache[abs] = entries\r\n  return cb(null, entries)\r\n}\r\n\r\nGlob.prototype._readdirError = function (f, er, cb) {\r\n  if (this.aborted)\r\n    return\r\n\r\n  // handle errors, and cache the information\r\n  switch (er.code) {\r\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\r\n    case 'ENOTDIR': // totally normal. means it *does* exist.\r\n      var abs = this._makeAbs(f)\r\n      this.cache[abs] = 'FILE'\r\n      if (abs === this.cwdAbs) {\r\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\r\n        error.path = this.cwd\r\n        error.code = er.code\r\n        this.emit('error', error)\r\n        this.abort()\r\n      }\r\n      break\r\n\r\n    case 'ENOENT': // not terribly unusual\r\n    case 'ELOOP':\r\n    case 'ENAMETOOLONG':\r\n    case 'UNKNOWN':\r\n      this.cache[this._makeAbs(f)] = false\r\n      break\r\n\r\n    default: // some unusual error.  Treat as failure.\r\n      this.cache[this._makeAbs(f)] = false\r\n      if (this.strict) {\r\n        this.emit('error', er)\r\n        // If the error is handled, then we abort\r\n        // if not, we threw out of here\r\n        this.abort()\r\n      }\r\n      if (!this.silent)\r\n        console.error('glob error', er)\r\n      break\r\n  }\r\n\r\n  return cb()\r\n}\r\n\r\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\r\n  var self = this\r\n  this._readdir(abs, inGlobStar, function (er, entries) {\r\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\r\n  })\r\n}\r\n\r\n\r\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\r\n  //console.error('pgs2', prefix, remain[0], entries)\r\n\r\n  // no entries means not a dir, so it can never have matches\r\n  // foo.txt/** doesn't match foo.txt\r\n  if (!entries)\r\n    return cb()\r\n\r\n  // test without the globstar, and with every child both below\r\n  // and replacing the globstar.\r\n  var remainWithoutGlobStar = remain.slice(1)\r\n  var gspref = prefix ? [ prefix ] : []\r\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\r\n\r\n  // the noGlobStar pattern exits the inGlobStar state\r\n  this._process(noGlobStar, index, false, cb)\r\n\r\n  var isSym = this.symlinks[abs]\r\n  var len = entries.length\r\n\r\n  // If it's a symlink, and we're in a globstar, then stop\r\n  if (isSym && inGlobStar)\r\n    return cb()\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var e = entries[i]\r\n    if (e.charAt(0) === '.' && !this.dot)\r\n      continue\r\n\r\n    // these two cases enter the inGlobStar state\r\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\r\n    this._process(instead, index, true, cb)\r\n\r\n    var below = gspref.concat(entries[i], remain)\r\n    this._process(below, index, true, cb)\r\n  }\r\n\r\n  cb()\r\n}\r\n\r\nGlob.prototype._processSimple = function (prefix, index, cb) {\r\n  // XXX review this.  Shouldn't it be doing the mounting etc\r\n  // before doing stat?  kinda weird?\r\n  var self = this\r\n  this._stat(prefix, function (er, exists) {\r\n    self._processSimple2(prefix, index, er, exists, cb)\r\n  })\r\n}\r\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\r\n\r\n  //console.error('ps2', prefix, exists)\r\n\r\n  if (!this.matches[index])\r\n    this.matches[index] = Object.create(null)\r\n\r\n  // If it doesn't exist, then just mark the lack of results\r\n  if (!exists)\r\n    return cb()\r\n\r\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\r\n    var trail = /[\\/\\\\]$/.test(prefix)\r\n    if (prefix.charAt(0) === '/') {\r\n      prefix = path.join(this.root, prefix)\r\n    } else {\r\n      prefix = path.resolve(this.root, prefix)\r\n      if (trail)\r\n        prefix += '/'\r\n    }\r\n  }\r\n\r\n  if (process.platform === 'win32')\r\n    prefix = prefix.replace(/\\\\/g, '/')\r\n\r\n  // Mark this as a match\r\n  this._emitMatch(index, prefix)\r\n  cb()\r\n}\r\n\r\n// Returns either 'DIR', 'FILE', or false\r\nGlob.prototype._stat = function (f, cb) {\r\n  var abs = this._makeAbs(f)\r\n  var needDir = f.slice(-1) === '/'\r\n\r\n  if (f.length > this.maxLength)\r\n    return cb()\r\n\r\n  if (!this.stat && ownProp(this.cache, abs)) {\r\n    var c = this.cache[abs]\r\n\r\n    if (Array.isArray(c))\r\n      c = 'DIR'\r\n\r\n    // It exists, but maybe not how we need it\r\n    if (!needDir || c === 'DIR')\r\n      return cb(null, c)\r\n\r\n    if (needDir && c === 'FILE')\r\n      return cb()\r\n\r\n    // otherwise we have to stat, because maybe c=true\r\n    // if we know it exists, but not what it is.\r\n  }\r\n\r\n  var exists\r\n  var stat = this.statCache[abs]\r\n  if (stat !== undefined) {\r\n    if (stat === false)\r\n      return cb(null, stat)\r\n    else {\r\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\r\n      if (needDir && type === 'FILE')\r\n        return cb()\r\n      else\r\n        return cb(null, type, stat)\r\n    }\r\n  }\r\n\r\n  var self = this\r\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\r\n  if (statcb)\r\n    self.fs.lstat(abs, statcb)\r\n\r\n  function lstatcb_ (er, lstat) {\r\n    if (lstat && lstat.isSymbolicLink()) {\r\n      // If it's a symlink, then treat it as the target, unless\r\n      // the target does not exist, then treat it as a file.\r\n      return self.fs.stat(abs, function (er, stat) {\r\n        if (er)\r\n          self._stat2(f, abs, null, lstat, cb)\r\n        else\r\n          self._stat2(f, abs, er, stat, cb)\r\n      })\r\n    } else {\r\n      self._stat2(f, abs, er, lstat, cb)\r\n    }\r\n  }\r\n}\r\n\r\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\r\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\r\n    this.statCache[abs] = false\r\n    return cb()\r\n  }\r\n\r\n  var needDir = f.slice(-1) === '/'\r\n  this.statCache[abs] = stat\r\n\r\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\r\n    return cb(null, false, stat)\r\n\r\n  var c = true\r\n  if (stat)\r\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\r\n  this.cache[abs] = this.cache[abs] || c\r\n\r\n  if (needDir && c === 'FILE')\r\n    return cb()\r\n\r\n  return cb(null, c, stat)\r\n}\r\n","module.exports = globSync\r\nglobSync.GlobSync = GlobSync\r\n\r\nvar rp = require('fs.realpath')\r\nvar minimatch = require('minimatch')\r\nvar Minimatch = minimatch.Minimatch\r\nvar Glob = require('./glob.js').Glob\r\nvar util = require('util')\r\nvar path = require('path')\r\nvar assert = require('assert')\r\nvar isAbsolute = require('path-is-absolute')\r\nvar common = require('./common.js')\r\nvar setopts = common.setopts\r\nvar ownProp = common.ownProp\r\nvar childrenIgnored = common.childrenIgnored\r\nvar isIgnored = common.isIgnored\r\n\r\nfunction globSync (pattern, options) {\r\n  if (typeof options === 'function' || arguments.length === 3)\r\n    throw new TypeError('callback provided to sync glob\\n'+\r\n                        'See: https://github.com/isaacs/node-glob/issues/167')\r\n\r\n  return new GlobSync(pattern, options).found\r\n}\r\n\r\nfunction GlobSync (pattern, options) {\r\n  if (!pattern)\r\n    throw new Error('must provide pattern')\r\n\r\n  if (typeof options === 'function' || arguments.length === 3)\r\n    throw new TypeError('callback provided to sync glob\\n'+\r\n                        'See: https://github.com/isaacs/node-glob/issues/167')\r\n\r\n  if (!(this instanceof GlobSync))\r\n    return new GlobSync(pattern, options)\r\n\r\n  setopts(this, pattern, options)\r\n\r\n  if (this.noprocess)\r\n    return this\r\n\r\n  var n = this.minimatch.set.length\r\n  this.matches = new Array(n)\r\n  for (var i = 0; i < n; i ++) {\r\n    this._process(this.minimatch.set[i], i, false)\r\n  }\r\n  this._finish()\r\n}\r\n\r\nGlobSync.prototype._finish = function () {\r\n  assert(this instanceof GlobSync)\r\n  if (this.realpath) {\r\n    var self = this\r\n    this.matches.forEach(function (matchset, index) {\r\n      var set = self.matches[index] = Object.create(null)\r\n      for (var p in matchset) {\r\n        try {\r\n          p = self._makeAbs(p)\r\n          var real = rp.realpathSync(p, self.realpathCache)\r\n          set[real] = true\r\n        } catch (er) {\r\n          if (er.syscall === 'stat')\r\n            set[self._makeAbs(p)] = true\r\n          else\r\n            throw er\r\n        }\r\n      }\r\n    })\r\n  }\r\n  common.finish(this)\r\n}\r\n\r\n\r\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\r\n  assert(this instanceof GlobSync)\r\n\r\n  // Get the first [n] parts of pattern that are all strings.\r\n  var n = 0\r\n  while (typeof pattern[n] === 'string') {\r\n    n ++\r\n  }\r\n  // now n is the index of the first one that is *not* a string.\r\n\r\n  // See if there's anything else\r\n  var prefix\r\n  switch (n) {\r\n    // if not, then this is rather simple\r\n    case pattern.length:\r\n      this._processSimple(pattern.join('/'), index)\r\n      return\r\n\r\n    case 0:\r\n      // pattern *starts* with some non-trivial item.\r\n      // going to readdir(cwd), but not include the prefix in matches.\r\n      prefix = null\r\n      break\r\n\r\n    default:\r\n      // pattern has some string bits in the front.\r\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\r\n      // or 'relative' like '../baz'\r\n      prefix = pattern.slice(0, n).join('/')\r\n      break\r\n  }\r\n\r\n  var remain = pattern.slice(n)\r\n\r\n  // get the list of entries.\r\n  var read\r\n  if (prefix === null)\r\n    read = '.'\r\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\r\n    if (!prefix || !isAbsolute(prefix))\r\n      prefix = '/' + prefix\r\n    read = prefix\r\n  } else\r\n    read = prefix\r\n\r\n  var abs = this._makeAbs(read)\r\n\r\n  //if ignored, skip processing\r\n  if (childrenIgnored(this, read))\r\n    return\r\n\r\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\r\n  if (isGlobStar)\r\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\r\n  else\r\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\r\n}\r\n\r\n\r\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\r\n  var entries = this._readdir(abs, inGlobStar)\r\n\r\n  // if the abs isn't a dir, then nothing can match!\r\n  if (!entries)\r\n    return\r\n\r\n  // It will only match dot entries if it starts with a dot, or if\r\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\r\n  var pn = remain[0]\r\n  var negate = !!this.minimatch.negate\r\n  var rawGlob = pn._glob\r\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\r\n\r\n  var matchedEntries = []\r\n  for (var i = 0; i < entries.length; i++) {\r\n    var e = entries[i]\r\n    if (e.charAt(0) !== '.' || dotOk) {\r\n      var m\r\n      if (negate && !prefix) {\r\n        m = !e.match(pn)\r\n      } else {\r\n        m = e.match(pn)\r\n      }\r\n      if (m)\r\n        matchedEntries.push(e)\r\n    }\r\n  }\r\n\r\n  var len = matchedEntries.length\r\n  // If there are no matched entries, then nothing matches.\r\n  if (len === 0)\r\n    return\r\n\r\n  // if this is the last remaining pattern bit, then no need for\r\n  // an additional stat *unless* the user has specified mark or\r\n  // stat explicitly.  We know they exist, since readdir returned\r\n  // them.\r\n\r\n  if (remain.length === 1 && !this.mark && !this.stat) {\r\n    if (!this.matches[index])\r\n      this.matches[index] = Object.create(null)\r\n\r\n    for (var i = 0; i < len; i ++) {\r\n      var e = matchedEntries[i]\r\n      if (prefix) {\r\n        if (prefix.slice(-1) !== '/')\r\n          e = prefix + '/' + e\r\n        else\r\n          e = prefix + e\r\n      }\r\n\r\n      if (e.charAt(0) === '/' && !this.nomount) {\r\n        e = path.join(this.root, e)\r\n      }\r\n      this._emitMatch(index, e)\r\n    }\r\n    // This was the last one, and no stats were needed\r\n    return\r\n  }\r\n\r\n  // now test all matched entries as stand-ins for that part\r\n  // of the pattern.\r\n  remain.shift()\r\n  for (var i = 0; i < len; i ++) {\r\n    var e = matchedEntries[i]\r\n    var newPattern\r\n    if (prefix)\r\n      newPattern = [prefix, e]\r\n    else\r\n      newPattern = [e]\r\n    this._process(newPattern.concat(remain), index, inGlobStar)\r\n  }\r\n}\r\n\r\n\r\nGlobSync.prototype._emitMatch = function (index, e) {\r\n  if (isIgnored(this, e))\r\n    return\r\n\r\n  var abs = this._makeAbs(e)\r\n\r\n  if (this.mark)\r\n    e = this._mark(e)\r\n\r\n  if (this.absolute) {\r\n    e = abs\r\n  }\r\n\r\n  if (this.matches[index][e])\r\n    return\r\n\r\n  if (this.nodir) {\r\n    var c = this.cache[abs]\r\n    if (c === 'DIR' || Array.isArray(c))\r\n      return\r\n  }\r\n\r\n  this.matches[index][e] = true\r\n\r\n  if (this.stat)\r\n    this._stat(e)\r\n}\r\n\r\n\r\nGlobSync.prototype._readdirInGlobStar = function (abs) {\r\n  // follow all symlinked directories forever\r\n  // just proceed as if this is a non-globstar situation\r\n  if (this.follow)\r\n    return this._readdir(abs, false)\r\n\r\n  var entries\r\n  var lstat\r\n  var stat\r\n  try {\r\n    lstat = this.fs.lstatSync(abs)\r\n  } catch (er) {\r\n    if (er.code === 'ENOENT') {\r\n      // lstat failed, doesn't exist\r\n      return null\r\n    }\r\n  }\r\n\r\n  var isSym = lstat && lstat.isSymbolicLink()\r\n  this.symlinks[abs] = isSym\r\n\r\n  // If it's not a symlink or a dir, then it's definitely a regular file.\r\n  // don't bother doing a readdir in that case.\r\n  if (!isSym && lstat && !lstat.isDirectory())\r\n    this.cache[abs] = 'FILE'\r\n  else\r\n    entries = this._readdir(abs, false)\r\n\r\n  return entries\r\n}\r\n\r\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\r\n  var entries\r\n\r\n  if (inGlobStar && !ownProp(this.symlinks, abs))\r\n    return this._readdirInGlobStar(abs)\r\n\r\n  if (ownProp(this.cache, abs)) {\r\n    var c = this.cache[abs]\r\n    if (!c || c === 'FILE')\r\n      return null\r\n\r\n    if (Array.isArray(c))\r\n      return c\r\n  }\r\n\r\n  try {\r\n    return this._readdirEntries(abs, this.fs.readdirSync(abs))\r\n  } catch (er) {\r\n    this._readdirError(abs, er)\r\n    return null\r\n  }\r\n}\r\n\r\nGlobSync.prototype._readdirEntries = function (abs, entries) {\r\n  // if we haven't asked to stat everything, then just\r\n  // assume that everything in there exists, so we can avoid\r\n  // having to stat it a second time.\r\n  if (!this.mark && !this.stat) {\r\n    for (var i = 0; i < entries.length; i ++) {\r\n      var e = entries[i]\r\n      if (abs === '/')\r\n        e = abs + e\r\n      else\r\n        e = abs + '/' + e\r\n      this.cache[e] = true\r\n    }\r\n  }\r\n\r\n  this.cache[abs] = entries\r\n\r\n  // mark and cache dir-ness\r\n  return entries\r\n}\r\n\r\nGlobSync.prototype._readdirError = function (f, er) {\r\n  // handle errors, and cache the information\r\n  switch (er.code) {\r\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\r\n    case 'ENOTDIR': // totally normal. means it *does* exist.\r\n      var abs = this._makeAbs(f)\r\n      this.cache[abs] = 'FILE'\r\n      if (abs === this.cwdAbs) {\r\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\r\n        error.path = this.cwd\r\n        error.code = er.code\r\n        throw error\r\n      }\r\n      break\r\n\r\n    case 'ENOENT': // not terribly unusual\r\n    case 'ELOOP':\r\n    case 'ENAMETOOLONG':\r\n    case 'UNKNOWN':\r\n      this.cache[this._makeAbs(f)] = false\r\n      break\r\n\r\n    default: // some unusual error.  Treat as failure.\r\n      this.cache[this._makeAbs(f)] = false\r\n      if (this.strict)\r\n        throw er\r\n      if (!this.silent)\r\n        console.error('glob error', er)\r\n      break\r\n  }\r\n}\r\n\r\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\r\n\r\n  var entries = this._readdir(abs, inGlobStar)\r\n\r\n  // no entries means not a dir, so it can never have matches\r\n  // foo.txt/** doesn't match foo.txt\r\n  if (!entries)\r\n    return\r\n\r\n  // test without the globstar, and with every child both below\r\n  // and replacing the globstar.\r\n  var remainWithoutGlobStar = remain.slice(1)\r\n  var gspref = prefix ? [ prefix ] : []\r\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\r\n\r\n  // the noGlobStar pattern exits the inGlobStar state\r\n  this._process(noGlobStar, index, false)\r\n\r\n  var len = entries.length\r\n  var isSym = this.symlinks[abs]\r\n\r\n  // If it's a symlink, and we're in a globstar, then stop\r\n  if (isSym && inGlobStar)\r\n    return\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var e = entries[i]\r\n    if (e.charAt(0) === '.' && !this.dot)\r\n      continue\r\n\r\n    // these two cases enter the inGlobStar state\r\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\r\n    this._process(instead, index, true)\r\n\r\n    var below = gspref.concat(entries[i], remain)\r\n    this._process(below, index, true)\r\n  }\r\n}\r\n\r\nGlobSync.prototype._processSimple = function (prefix, index) {\r\n  // XXX review this.  Shouldn't it be doing the mounting etc\r\n  // before doing stat?  kinda weird?\r\n  var exists = this._stat(prefix)\r\n\r\n  if (!this.matches[index])\r\n    this.matches[index] = Object.create(null)\r\n\r\n  // If it doesn't exist, then just mark the lack of results\r\n  if (!exists)\r\n    return\r\n\r\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\r\n    var trail = /[\\/\\\\]$/.test(prefix)\r\n    if (prefix.charAt(0) === '/') {\r\n      prefix = path.join(this.root, prefix)\r\n    } else {\r\n      prefix = path.resolve(this.root, prefix)\r\n      if (trail)\r\n        prefix += '/'\r\n    }\r\n  }\r\n\r\n  if (process.platform === 'win32')\r\n    prefix = prefix.replace(/\\\\/g, '/')\r\n\r\n  // Mark this as a match\r\n  this._emitMatch(index, prefix)\r\n}\r\n\r\n// Returns either 'DIR', 'FILE', or false\r\nGlobSync.prototype._stat = function (f) {\r\n  var abs = this._makeAbs(f)\r\n  var needDir = f.slice(-1) === '/'\r\n\r\n  if (f.length > this.maxLength)\r\n    return false\r\n\r\n  if (!this.stat && ownProp(this.cache, abs)) {\r\n    var c = this.cache[abs]\r\n\r\n    if (Array.isArray(c))\r\n      c = 'DIR'\r\n\r\n    // It exists, but maybe not how we need it\r\n    if (!needDir || c === 'DIR')\r\n      return c\r\n\r\n    if (needDir && c === 'FILE')\r\n      return false\r\n\r\n    // otherwise we have to stat, because maybe c=true\r\n    // if we know it exists, but not what it is.\r\n  }\r\n\r\n  var exists\r\n  var stat = this.statCache[abs]\r\n  if (!stat) {\r\n    var lstat\r\n    try {\r\n      lstat = this.fs.lstatSync(abs)\r\n    } catch (er) {\r\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\r\n        this.statCache[abs] = false\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (lstat && lstat.isSymbolicLink()) {\r\n      try {\r\n        stat = this.fs.statSync(abs)\r\n      } catch (er) {\r\n        stat = lstat\r\n      }\r\n    } else {\r\n      stat = lstat\r\n    }\r\n  }\r\n\r\n  this.statCache[abs] = stat\r\n\r\n  var c = true\r\n  if (stat)\r\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\r\n\r\n  this.cache[abs] = this.cache[abs] || c\r\n\r\n  if (needDir && c === 'FILE')\r\n    return false\r\n\r\n  return c\r\n}\r\n\r\nGlobSync.prototype._mark = function (p) {\r\n  return common.mark(this, p)\r\n}\r\n\r\nGlobSync.prototype._makeAbs = function (f) {\r\n  return common.makeAbs(this, f)\r\n}\r\n","exports.setopts = setopts\r\nexports.ownProp = ownProp\r\nexports.makeAbs = makeAbs\r\nexports.finish = finish\r\nexports.mark = mark\r\nexports.isIgnored = isIgnored\r\nexports.childrenIgnored = childrenIgnored\r\n\r\nfunction ownProp (obj, field) {\r\n  return Object.prototype.hasOwnProperty.call(obj, field)\r\n}\r\n\r\nvar fs = require(\"fs\")\r\nvar path = require(\"path\")\r\nvar minimatch = require(\"minimatch\")\r\nvar isAbsolute = require(\"path-is-absolute\")\r\nvar Minimatch = minimatch.Minimatch\r\n\r\nfunction alphasort (a, b) {\r\n  return a.localeCompare(b, 'en')\r\n}\r\n\r\nfunction setupIgnores (self, options) {\r\n  self.ignore = options.ignore || []\r\n\r\n  if (!Array.isArray(self.ignore))\r\n    self.ignore = [self.ignore]\r\n\r\n  if (self.ignore.length) {\r\n    self.ignore = self.ignore.map(ignoreMap)\r\n  }\r\n}\r\n\r\n// ignore patterns are always in dot:true mode.\r\nfunction ignoreMap (pattern) {\r\n  var gmatcher = null\r\n  if (pattern.slice(-3) === '/**') {\r\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\r\n    gmatcher = new Minimatch(gpattern, { dot: true })\r\n  }\r\n\r\n  return {\r\n    matcher: new Minimatch(pattern, { dot: true }),\r\n    gmatcher: gmatcher\r\n  }\r\n}\r\n\r\nfunction setopts (self, pattern, options) {\r\n  if (!options)\r\n    options = {}\r\n\r\n  // base-matching: just use globstar for that.\r\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\r\n    if (options.noglobstar) {\r\n      throw new Error(\"base matching requires globstar\")\r\n    }\r\n    pattern = \"**/\" + pattern\r\n  }\r\n\r\n  self.silent = !!options.silent\r\n  self.pattern = pattern\r\n  self.strict = options.strict !== false\r\n  self.realpath = !!options.realpath\r\n  self.realpathCache = options.realpathCache || Object.create(null)\r\n  self.follow = !!options.follow\r\n  self.dot = !!options.dot\r\n  self.mark = !!options.mark\r\n  self.nodir = !!options.nodir\r\n  if (self.nodir)\r\n    self.mark = true\r\n  self.sync = !!options.sync\r\n  self.nounique = !!options.nounique\r\n  self.nonull = !!options.nonull\r\n  self.nosort = !!options.nosort\r\n  self.nocase = !!options.nocase\r\n  self.stat = !!options.stat\r\n  self.noprocess = !!options.noprocess\r\n  self.absolute = !!options.absolute\r\n  self.fs = options.fs || fs\r\n\r\n  self.maxLength = options.maxLength || Infinity\r\n  self.cache = options.cache || Object.create(null)\r\n  self.statCache = options.statCache || Object.create(null)\r\n  self.symlinks = options.symlinks || Object.create(null)\r\n\r\n  setupIgnores(self, options)\r\n\r\n  self.changedCwd = false\r\n  var cwd = process.cwd()\r\n  if (!ownProp(options, \"cwd\"))\r\n    self.cwd = cwd\r\n  else {\r\n    self.cwd = path.resolve(options.cwd)\r\n    self.changedCwd = self.cwd !== cwd\r\n  }\r\n\r\n  self.root = options.root || path.resolve(self.cwd, \"/\")\r\n  self.root = path.resolve(self.root)\r\n  if (process.platform === \"win32\")\r\n    self.root = self.root.replace(/\\\\/g, \"/\")\r\n\r\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\r\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\r\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\r\n  if (process.platform === \"win32\")\r\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\r\n  self.nomount = !!options.nomount\r\n\r\n  // disable comments and negation in Minimatch.\r\n  // Note that they are not supported in Glob itself anyway.\r\n  options.nonegate = true\r\n  options.nocomment = true\r\n\r\n  self.minimatch = new Minimatch(pattern, options)\r\n  self.options = self.minimatch.options\r\n}\r\n\r\nfunction finish (self) {\r\n  var nou = self.nounique\r\n  var all = nou ? [] : Object.create(null)\r\n\r\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\r\n    var matches = self.matches[i]\r\n    if (!matches || Object.keys(matches).length === 0) {\r\n      if (self.nonull) {\r\n        // do like the shell, and spit out the literal glob\r\n        var literal = self.minimatch.globSet[i]\r\n        if (nou)\r\n          all.push(literal)\r\n        else\r\n          all[literal] = true\r\n      }\r\n    } else {\r\n      // had matches\r\n      var m = Object.keys(matches)\r\n      if (nou)\r\n        all.push.apply(all, m)\r\n      else\r\n        m.forEach(function (m) {\r\n          all[m] = true\r\n        })\r\n    }\r\n  }\r\n\r\n  if (!nou)\r\n    all = Object.keys(all)\r\n\r\n  if (!self.nosort)\r\n    all = all.sort(alphasort)\r\n\r\n  // at *some* point we statted all of these\r\n  if (self.mark) {\r\n    for (var i = 0; i < all.length; i++) {\r\n      all[i] = self._mark(all[i])\r\n    }\r\n    if (self.nodir) {\r\n      all = all.filter(function (e) {\r\n        var notDir = !(/\\/$/.test(e))\r\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\r\n        if (notDir && c)\r\n          notDir = c !== 'DIR' && !Array.isArray(c)\r\n        return notDir\r\n      })\r\n    }\r\n  }\r\n\r\n  if (self.ignore.length)\r\n    all = all.filter(function(m) {\r\n      return !isIgnored(self, m)\r\n    })\r\n\r\n  self.found = all\r\n}\r\n\r\nfunction mark (self, p) {\r\n  var abs = makeAbs(self, p)\r\n  var c = self.cache[abs]\r\n  var m = p\r\n  if (c) {\r\n    var isDir = c === 'DIR' || Array.isArray(c)\r\n    var slash = p.slice(-1) === '/'\r\n\r\n    if (isDir && !slash)\r\n      m += '/'\r\n    else if (!isDir && slash)\r\n      m = m.slice(0, -1)\r\n\r\n    if (m !== p) {\r\n      var mabs = makeAbs(self, m)\r\n      self.statCache[mabs] = self.statCache[abs]\r\n      self.cache[mabs] = self.cache[abs]\r\n    }\r\n  }\r\n\r\n  return m\r\n}\r\n\r\n// lotta situps...\r\nfunction makeAbs (self, f) {\r\n  var abs = f\r\n  if (f.charAt(0) === '/') {\r\n    abs = path.join(self.root, f)\r\n  } else if (isAbsolute(f) || f === '') {\r\n    abs = f\r\n  } else if (self.changedCwd) {\r\n    abs = path.resolve(self.cwd, f)\r\n  } else {\r\n    abs = path.resolve(f)\r\n  }\r\n\r\n  if (process.platform === 'win32')\r\n    abs = abs.replace(/\\\\/g, '/')\r\n\r\n  return abs\r\n}\r\n\r\n\r\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\r\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\r\nfunction isIgnored (self, path) {\r\n  if (!self.ignore.length)\r\n    return false\r\n\r\n  return self.ignore.some(function(item) {\r\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\r\n  })\r\n}\r\n\r\nfunction childrenIgnored (self, path) {\r\n  if (!self.ignore.length)\r\n    return false\r\n\r\n  return self.ignore.some(function(item) {\r\n    return !!(item.gmatcher && item.gmatcher.match(path))\r\n  })\r\n}\r\n"]}